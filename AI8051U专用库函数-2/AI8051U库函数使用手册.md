# AI8051U 专用库函数使用手册

> **版本**: V2.0  
> **适用芯片**: STC AI8051U 系列  
> **编译器**: Keil C51  
> **最后更新**: 2025年5月

---

## 📑 目录

1. [快速开始](#快速开始)
2. [库函数概述](#库函数概述)
3. [模块详细说明](#模块详细说明)
4. [高级特性](#高级特性)
5. [常见问题](#常见问题)
6. [附录](#附录)

---

## 快速开始

### 环境配置

#### 1. 硬件要求
- STC AI8051U 系列单片机
- USB Type-C 数据线（支持USB-CDC调试）
- 实验板或面包板

#### 2. 软件要求
- Keil µVision 5
- STC-ISP 下载工具
- 库函数文件包

#### 3. 创建第一个项目

**步骤 1**: 在Keil中创建新项目并选择芯片型号

**步骤 2**: 添加必要文件到项目
```
项目目录/
├── main.c           # 主程序
├── AI8051U.H        # 芯片头文件
├── set_io.c         # IO库函数源文件
├── set_io.h         # IO库函数头文件
└── stc_usb_cdc_32g.LIB  # USB库（可选）
```

**步骤 3**: 使用 Auto_Keil.exe 自动配置工程
- 关闭Keil工程
- 双击项目文件夹中的 `Auto_Keil.exe`
- 重新打开工程

**步骤 4**: 编写代码（LED闪烁示例）

```c
#include "AI8051U.h"
#include "set_io.h"
#include "set_timer.h"

void main(void)
{
    EAXFR = 1;  // 允许访问扩展寄存器
    WTST = 0;
    CKCON = 0;
    
    // 配置P00为推挽输出
    set_io_mode(pp_mode, Pin00, Pin_End);
    
    // 配置Timer0为100ms定时
    set_timer_mode(Timer0, "100ms", Timer_End);
    
    EA = 1;  // 开启总中断
    
    while(1)
    {
        if(get_timer_state(Timer0))
        {
            P00 = ~P00;  // 翻转LED
        }
    }
}
```

**步骤 5**: 编译并下载

---

## 库函数概述

### 模块列表

| 模块 | 文件 | 功能描述 |
|------|------|----------|
| IO控制 | `set_io.c/h` | GPIO配置、模式设置 |
| IO中断 | `io_int.c/h` | 独立IO中断、边沿检测 |
| 定时器 | `set_timer.c/h` | 6路定时器、外部计数 |
| 串口通信 | `set_uart.c/h` | 4路UART、DMA收发 |
| ADC采样 | `set_adc.c/h` | 16通道ADC、自动转换 |
| PWM控制 | `set_pwm.c/h` | 8路PWM、输入捕获 |
| I2C通信 | `set_i2c.c/h` | I2C主机、指令串 |
| SPI通信 | `set_spi.c/h` | 3路SPI、DMA模式 |
| EEPROM | `set_eeprom.c/h` | 数据存储、均衡磨损 |
| 协程调度 | `set_task.c/h` | 轻量级多任务 |

### 设计特点

#### 1. 变长参数支持
```c
// 一次配置多个引脚
set_io_mode(pp_mode, Pin00, Pin01, Pin02, Pin_End);
```

#### 2. 参数乱序输入
```c
// 以下两种写法等效
set_uart_mode(Uart1, "9600bps", Uart1_P36_7, Uart_End);
set_uart_mode(Uart1, Uart1_P36_7, "9600bps", Uart_End);
```

#### 3. 默认值机制
```c
// 不指定参数时使用默认值
set_uart_mode(Uart1, Uart_End);  // 115200bps, 64byte, P30/P31
```

#### 4. 智能单位识别
```c
set_timer_mode(Timer0, "100ms", Timer_End);  // 毫秒
set_timer_mode(Timer1, "50hz", Timer_End);   // 频率
set_pwm_mode(Pwm1, "10khz", "75.5%", Pwm_End);  // 支持小数
```

---

## 模块详细说明

### 1. IO控制模块 (set_io)

#### 1.1 引脚命名

引脚使用 `Pin` 前缀加端口号：
```c
Pin00, Pin01, ..., Pin07  // P0口
Pin10, Pin11, ..., Pin17  // P1口
Pin20, Pin21, ..., Pin27  // P2口
Pin30, Pin31, ..., Pin37  // P3口
Pin40, Pin41, ..., Pin47  // P4口
Pin50, Pin51, ..., Pin57  // P5口
```

#### 1.2 IO模式

| 模式 | 宏定义 | 说明 |
|------|--------|------|
| 准双向 | `pu_mode` | 默认模式，可读可写 |
| 推挽输出 | `pp_mode` | 强驱动输出 |
| 高阻输入 | `hz_mode` | 高阻抗输入 |
| 开漏输出 | `od_mode` | 需外部上拉 |

#### 1.3 特殊配置

```c
// 上拉/下拉电阻
en_pur / dis_pur    // 使能/禁用上拉电阻
en_pdr / dis_pdr    // 使能/禁用下拉电阻

// 驱动能力
big_current / small_current    // 大/小驱动电流
high_speed / low_speed         // 高/低转换速度

// 施密特触发器
en_schmitt_trig / dis_schmitt_trig

// 数字输入使能
en_dinput / dis_dinput
```

#### 1.4 使用示例

```c
// 示例1：配置LED输出
set_io_mode(pp_mode, Pin00, Pin01, Pin02, Pin_End);

// 示例2：配置按键输入
set_io_mode(hz_mode, Pin32, Pin_End);
set_io_mode(en_pur, Pin32, Pin_End);  // 使能上拉

// 示例3：大电流驱动继电器
set_io_mode(pp_mode, Pin40, Pin_End);
set_io_mode(big_current, Pin40, Pin_End);

// 示例4：开漏I2C引脚
set_io_mode(od_mode, Pin23, Pin_End);
set_io_mode(en_pur, Pin23, Pin_End);
```

---

### 2. IO中断模块 (io_int)

#### 2.1 中断模式

| 模式 | 宏定义 | 说明 |
|------|--------|------|
| 下降沿 | `falling_edge_mode` | 高到低触发 |
| 上升沿 | `rising_edge_mode` | 低到高触发 |
| 低电平 | `low_level_mode` | 低电平触发 |
| 高电平 | `high_level_mode` | 高电平触发 |

#### 2.2 API函数

```c
// 设置中断模式
void set_ioint_mode(int mode, ...);

// 获取中断状态（自动清除）
char get_ioint_state(io_name pin);

// 设置中断回调函数
void set_ioint_isr(io_name pin, void (*isr)(void));
```

#### 2.3 使用示例

```c
// 示例1：按键中断
set_io_mode(hz_mode, Pin34, Pin_End);
set_io_mode(en_pur, Pin34, Pin_End);
set_ioint_mode(falling_edge_mode, Pin34, Pin_End);
set_ioint_mode(en_int, Pin34, Pin_End);
EA = 1;

while(1)
{
    if(get_ioint_state(Pin34))
    {
        P00 = ~P00;  // 按键按下，LED翻转
    }
}

// 示例2：使用回调函数
void key_isr(void)
{
    P00 = ~P00;
}

void main(void)
{
    EAXFR = 1; WTST = 0; CKCON = 0;
    set_io_mode(hz_mode, Pin34, Pin_End);
    set_io_mode(en_pur, Pin34, Pin_End);
    set_ioint_mode(falling_edge_mode, Pin34, Pin_End);
    set_ioint_mode(en_int, Pin34, Pin_End);
    set_ioint_isr(Pin34, key_isr);  // 注册回调
    EA = 1;
    while(1);
}
```

---

### 3. 定时器模块 (set_timer)

#### 3.1 支持的定时器

- Timer0, Timer1, Timer2, Timer3, Timer4, Timer11

#### 3.2 时间单位支持

| 单位 | 格式示例 | 说明 |
|------|----------|------|
| 秒 | `"1s"`, `"0.5s"` | 支持小数 |
| 毫秒 | `"100ms"`, `"1.5ms"` | 常用单位 |
| 微秒 | `"500us"` | 高精度 |
| 频率 | `"50hz"`, `"1000hz"` | 赫兹 |

#### 3.3 API函数

```c
// 配置定时器
void set_timer_mode(timer_num num, ...);

// 获取定时器状态
char get_timer_state(timer_num num);

// 获取外部脉冲计数
unsigned int get_timer_cnt(timer_num num);

// 设置中断回调
void set_timer_isr(timer_num num, void (*isr)(void));
```

#### 3.4 使用示例

```c
// 示例1：100ms定时
set_timer_mode(Timer0, "100ms", Timer_End);
EA = 1;

while(1)
{
    if(get_timer_state(Timer0))
    {
        // 每100ms执行一次
        P00 = ~P00;
    }
}

// 示例2：1kHz频率输出
set_timer_mode(Timer1, "1000hz", En_OutClk, Timer_End);
// T1CLKO = P34

// 示例3：外部脉冲计数
set_timer_mode(Timer0, Cnt_Mode, Timer_End);
EA = 1;

while(1)
{
    unsigned int cnt = get_timer_cnt(Timer0);
    // 读取后自动清零
}

// 示例4：使用回调函数
void timer_isr(void)
{
    static int cnt = 0;
    if(++cnt >= 10)
    {
        cnt = 0;
        P00 = ~P00;  // 每10次中断翻转一次
    }
}

void main(void)
{
    EAXFR = 1; WTST = 0; CKCON = 0;
    set_timer_mode(Timer0, "10ms", Timer_End);
    set_timer_isr(Timer0, timer_isr);
    EA = 1;
    while(1);
}
```

---

### 4. 串口通信模块 (set_uart)

#### 4.1 串口资源

- Uart1, Uart2, Uart3, Uart4

#### 4.2 引脚切换

```c
// Uart1
Uart1_P30_1  // P30(RXD), P31(TXD) - 默认
Uart1_P36_7  // P36(RXD), P37(TXD)
Uart1_P16_7  // P16(RXD), P17(TXD)
Uart1_P43_4  // P43(RXD), P44(TXD)

// Uart2
Uart2_P12_3  // P12(RXD), P13(TXD) - 默认
Uart2_P42_3  // P42(RXD), P43(TXD)

// Uart3
Uart3_P00_1  // P00(RXD), P01(TXD) - 默认
Uart3_P50_1  // P50(RXD), P51(TXD)

// Uart4
Uart4_P02_3  // P02(RXD), P03(TXD) - 默认
Uart4_P52_3  // P52(RXD), P53(TXD)
```

#### 4.3 API函数

```c
// 配置串口
void set_uart_mode(uart_name uart, ...);

// 获取接收状态
char get_uart_state(uart_name uart);

// 发送数据
void uart_printf(uart_name uart, ...);
```

#### 4.4 使用示例

```c
// 示例1：基本配置
set_uart_mode(Uart1, Uart_End);  // 默认115200bps

// 示例2：自定义波特率
set_uart_mode(Uart1, "9600bps", Uart_End);

// 示例3：多串口不同波特率
set_uart_mode(Uart1, "115200bps", Use_Timerx, Uart_End);
set_uart_mode(Uart2, "9600bps", Use_Timerx, Uart_End);

// 示例4：格式化输出
uart_printf(Uart1, "Temperature: %d\r\n", temp);

// 示例5：HEX单字节发送
uart_printf(Uart1, Hex_Mode, 0x55);

// 示例6：缓冲区发送
char buf[10] = {0x01, 0x02, 0x03};
uart_printf(Uart1, Buff_Mode, buf, 3);

// 示例7：接收数据
while(1)
{
    if(get_uart_state(Uart1))
    {
        // 接收到数据，存在_uart1_rx_buff中
        int num;
        sscanf(_uart1_rx_buff, "cnt:%d", &num);
        uart_printf(Uart1, "Received: %d\r\n", num);
    }
}

// 示例8：超时中断配置
set_uart_mode(Uart1, "115200bps", "32byte", Uart_End);
// 32个字节超时后触发中断
```

---

### 5. ADC采样模块 (set_adc)

#### 5.1 ADC通道

```c
Adc0_P10 ~ Adc7_P17   // P1口通道
Adc8_P00 ~ Adc14_P06  // P0口通道
Adc15_1_19V           // 内部1.19V基准
```

#### 5.2 采样模式

| 模式 | 宏定义 | 说明 |
|------|--------|------|
| 单次 | `single_mode` | 采样一次后停止 |
| 循环 | `cycl_mode` | 连续自动采样 |

#### 5.3 API函数

```c
// 配置ADC
void set_adc_mode(adc_mode mode, ...);

// 获取转换状态
char get_adc_state(adc_ch ch);

// 读取结果（外部变量）
extern unsigned int adc_value[16];
```

#### 5.4 使用示例

```c
// 示例1：单通道循环采样
set_adc_mode(cycl_mode, Adc0_P10, Adc_End);
EA = 1;

while(1)
{
    if(get_adc_state(Adc0_P10))
    {
        unsigned int val = adc_value[Adc0_P10];
        uart_printf(Uart1, "ADC: %d\r\n", val);
    }
}

// 示例2：多通道循环采样
set_adc_mode(cycl_mode, Adc0_P10, Adc1_P11, Adc2_P12, Adc_End);
EA = 1;

while(1)
{
    if(get_adc_state(Adc0_P10))
    {
        uart_printf(Uart1, "CH0:%d ", adc_value[Adc0_P10]);
    }
    if(get_adc_state(Adc1_P11))
    {
        uart_printf(Uart1, "CH1:%d ", adc_value[Adc1_P11]);
    }
    if(get_adc_state(Adc2_P12))
    {
        uart_printf(Uart1, "CH2:%d\r\n", adc_value[Adc2_P12]);
    }
}

// 示例3：单次采样
set_adc_mode(single_mode, Adc0_P10, Adc_End);
EA = 1;

while(1)
{
    if(get_adc_state(Adc0_P10))
    {
        // 采样完成，只执行一次
        unsigned int val = adc_value[Adc0_P10];
        // 需要再次采样时重新配置
        set_adc_mode(single_mode, Adc0_P10, Adc_End);
    }
}
```

---

### 6. PWM控制模块 (set_pwm)

#### 6.1 PWM通道

- Pwm1 ~ Pwm4：PWMA组（共享周期）
- Pwm5 ~ Pwm8：PWMB组（共享周期）

#### 6.2 引脚切换

```c
// PWM1（P通道/N通道）
Pwm1_P10_11, Pwm1_P00_01, Pwm1_P20_21

// PWM2
Pwm2_P12_13, Pwm2_P02_03, Pwm2_P22_23

// PWM3
Pwm3_P14_15, Pwm3_P04_05, Pwm3_P24_25

// PWM4
Pwm4_P16_17, Pwm4_P06_07, Pwm4_P26_27

// PWM5~8（仅P通道）
Pwm5_P01, Pwm5_P11, Pwm5_P21, Pwm5_P50
// ... (类似定义)
```

#### 6.3 输出模式

```c
En_Out_P    // 仅P通道输出（默认）
En_Out_N    // 仅N通道输出
En_Out_PN   // P和N互补输出
Dis_Out     // 关闭输出
```

#### 6.4 API函数

```c
// 配置PWM
void set_pwm_mode(pwm_name pwm, ...);

// 动态调整占空比
void set_pwm_duty(pwm_name pwm, float duty);

// 获取输入捕获周期
float get_pwm_period(pwm_name pwm, dat_unit unit);

// 获取输入捕获占空比
float get_pwm_duty(pwm_inx pwm);
```

#### 6.5 使用示例

```c
// 示例1：基本PWM输出
set_io_mode(pp_mode, Pin00, Pin_End);
set_pwm_mode(Pwm1, Pwm1_P00_01, "10khz", "50%", Pwm_End);
EA = 1;

// 示例2：动态调整占空比
set_pwm_mode(Pwm1, "1khz", "30%", Pwm_End);
EA = 1;

while(1)
{
    set_pwm_duty(Pwm1, 50.0);  // 调整到50%
    delay_ms(1000);
    set_pwm_duty(Pwm1, 75.5);  // 调整到75.5%
    delay_ms(1000);
}

// 示例3：互补输出（H桥驱动）
set_io_mode(pp_mode, Pin00, Pin01, Pin_End);
set_pwm_mode(Pwm1, Pwm1_P00_01, "20khz", "80%", 
             En_Out_PN, "50clk", Pwm_End);
// 50clk死区时间

// 示例4：输入捕获频率
set_io_mode(hz_mode, Pin01, Pin_End);
set_pwm_mode(Pwm5, Pwm5_P01, Pwm_In_Mode, 
             Self_Capture, Cap_In_Rising_Edge, Pwm_End);
set_pwm_mode(Pwm6, Pwm_In_Mode, 
             Cross_Capture, Cap_In_Falling_Edge, Pwm_End);
EA = 1;

while(1)
{
    float freq = get_pwm_period(Pwm5, khz);
    float duty = get_pwm_duty(Pwm5_Pwm6);
    uart_printf(Uart1, "Freq:%.2fkHz Duty:%.2f%%\r\n", 
                freq, duty);
    delay_ms(100);
}
```

---

### 7. I2C通信模块 (set_i2c)

#### 7.1 I2C引脚

```c
I2c_P24_3  // P24(SCL), P23(SDA) - 默认
I2c_P15_4  // P15(SCL), P14(SDA)
I2c_P32_3  // P32(SCL), P33(SDA)
```

#### 7.2 I2C指令

| 指令 | 说明 |
|------|------|
| `Start` | 起始信号 |
| `Tx_Dat` | 发送数据 |
| `Rack` | 接收ACK |
| `Rx_Dat` | 接收数据 |
| `Tack` | 发送ACK |
| `Tnak` | 发送NACK |
| `Stop` | 停止信号 |
| `S_Tx_Rack` | Start+Tx+Rack组合 |
| `Tx_Rack` | Tx+Rack组合 |
| `Rx_Tack` | Rx+Tack组合 |
| `Rx_Tnak` | Rx+Tnak组合 |

#### 7.3 API函数

```c
// 配置I2C
void set_i2c_mode(i2c_name i2c, ...);

// 执行指令串
void set_i2c_cmd(i2c_name i2c, int task_num, ...);

// 获取任务状态
char get_i2c_state(i2c_name i2c, int task_num);
```

#### 7.4 使用示例

```c
// 示例1：配置I2C
set_i2c_mode(I2c0, "400khz", I2c_P24_3, I2c_End);

// 示例2：写EEPROM
set_i2c_cmd(I2c0, 0, S_Tx_Rack, 0xa0, 
            Tx_Rack, 0x00, Tx_Rack, 0x55, 
            Stop, Cmd_End);

// 示例3：读EEPROM
char data;
set_i2c_cmd(I2c0, 0, S_Tx_Rack, 0xa0, Tx_Rack, 0x00, 
            S_Tx_Rack, 0xa1, Rx_Tnak, &data, 
            Stop, Cmd_End);

while(1)
{
    if(get_i2c_state(I2c0, 0))
    {
        uart_printf(Uart1, "Data: 0x%02X\r\n", data);
        break;
    }
}

// 示例4：MPU6050读取
int AccX, AccY, AccZ;
set_i2c_mode(I2c0, I2c_End);
set_i2c_cmd(I2c0, 0, S_Tx_Rack, 0xd0, Tx_Rack, 0x3b, 
            S_Tx_Rack, 0xd1, 
            Rx_Tack, (char*)&AccX, Rx_Tack, ((char*)&AccX)+1,
            Rx_Tack, (char*)&AccY, Rx_Tack, ((char*)&AccY)+1,
            Rx_Tack, (char*)&AccZ, Rx_Tnak, ((char*)&AccZ)+1,
            Stop, Cmd_End);

while(1)
{
    if(get_i2c_state(I2c0, 0))
    {
        uart_printf(Uart1, "Acc: %d,%d,%d\r\n", 
                    AccX, AccY, AccZ);
        delay_ms(100);
        // 再次读取
        set_i2c_cmd(I2c0, 0, /* 重复上面的指令 */);
    }
}
```

---

### 8. SPI通信模块 (set_spi)

#### 8.1 SPI资源

- SPI0：独立SPI接口
- SPI1：占用Uart1资源
- SPI2：占用Uart2资源

#### 8.2 引脚切换

```c
// 顺序：SS-MOSI-MISO-SCLK
Spi_P14_5_6_7  // 默认
Spi_P24_5_6_7
Spi_P40_1_2_3
Spi_P35_4_3_2
```

#### 8.3 时钟配置

```c
Spi_ClkDiv_2   // 2分频（最快）
Spi_ClkDiv_4   // 4分频
Spi_ClkDiv_8   // 8分频
Spi_ClkDiv_16  // 16分频（默认）
```

#### 8.4 模式配置

```c
// 时钟极性和相位
High_Falling  // CPOL=1, CPHA=1（默认）
Low_Rising    // CPOL=0, CPHA=0

// 数据顺序
MSB  // 高位先行（默认）
LSB  // 低位先行
```

#### 8.5 API函数

```c
// 配置SPI
void set_spi_mode(spi_name spi, ...);

// 获取收发状态
char get_spi_state(spi_name spi);

// 发送数据
void spi_printf(spi_name spi, ...);
```

#### 8.6 使用示例

```c
// 示例1：基本配置
set_spi_mode(SPI0, Spi_End);  // 全默认配置

// 示例2：自定义配置
set_spi_mode(SPI0, Spi_P14_5_6_7, Spi_ClkDiv_4, 
             High_Falling, MSB, Spi_End);

// 示例3：发送单字节
spi_printf(SPI0, Hex_Mode, 0x55);

while(1)
{
    if(get_spi_state(SPI0))
    {
        // 收发完成
        char rx_data = _spi0_rx_buff[0];
        break;
    }
}

// 示例4：发送缓冲区
char tx_buf[10] = {0x01, 0x02, 0x03, 0x04, 0x05};
spi_printf(SPI0, Buff_Mode, tx_buf, 5);

while(1)
{
    if(get_spi_state(SPI0))
    {
        // 收发完成，数据在_spi0_rx_buff中
        for(int i = 0; i < 5; i++)
        {
            uart_printf(Uart1, "0x%02X ", _spi0_rx_buff[i]);
        }
        break;
    }
}

// 示例5：AD9833 DDS芯片控制
set_io_mode(pp_mode, Pin14, Pin15, Pin16, Pin17, Pin_End);
set_spi_mode(SPI0, Spi_ClkDiv_2, Spi_End);
EA = 1;

// 写入频率寄存器
unsigned int freq_word = 1000;  // 1kHz
char cmd[4];
cmd[0] = 0x21;
cmd[1] = 0x00;
cmd[2] = (freq_word >> 8) & 0xFF;
cmd[3] = freq_word & 0xFF;

P14 = 0;  // SS拉低
spi_printf(SPI0, Buff_Mode, cmd, 4);
while(!get_spi_state(SPI0));
P14 = 1;  // SS拉高
```

---

### 9. EEPROM模块 (set_eeprom)

#### 9.1 基础操作

```c
// 读单字节
char val = set_eeprom_base(Read_Byte, 0x0000);

// 写单字节
set_eeprom_base(Write_Byte, 0x0000, 0x55);

// 读缓冲区
char buf[10];
set_eeprom_base(Read_Buff, 0x0000, buf, 10);

// 写缓冲区
char buf[10] = {1, 2, 3, 4, 5};
set_eeprom_base(Write_Buff, 0x0000, buf, 10);

// 擦除扇区
set_eeprom_base(Erase_Sector, 0x0000);
```

#### 9.2 变量绑定（推荐）

```c
// 支持自动均衡磨损

// 示例1：保存单个变量
int settings = 1234;
set_eeprom_mode(Hex_Mode, &settings, sizeof(settings));
set_eeprom_sync(Push);  // 保存到EEPROM

// 断电后
set_eeprom_sync(Pull);  // 从EEPROM读取
// settings现在是1234

// 示例2：保存多个变量
struct Config {
    int temperature;
    int humidity;
    int pressure;
} config;

config.temperature = 25;
config.humidity = 60;
config.pressure = 1013;

set_eeprom_mode(Hex_Mode, &config, sizeof(config));
set_eeprom_sync(Push);

// 示例3：周期性保存
int cnt = 0;
set_eeprom_mode(Hex_Mode, &cnt, sizeof(cnt));
set_eeprom_sync(Pull);  // 读取上次值

while(1)
{
    cnt++;
    if(cnt % 100 == 0)
    {
        set_eeprom_sync(Push);  // 每100次保存一次
    }
}
```

**注意事项**：
- 绑定顺序不能改变，否则会读取错误数据
- 最多支持10个变量绑定（可修改 `EEPROM_Pack_Max`）
- 自动均衡磨损，延长寿命10倍以上

---

### 10. 协程调度模块 (set_task) ⭐

#### 10.1 协程宏定义

```c
task_start(task_num)   // 开始协程
task_delay(ms)         // 延时（毫秒）
task_wait(condition)   // 条件等待
task_for(init, cnt)    // for循环
task_while(condition)  // while循环
task_break(condition)  // 跳出循环
task_end(reload)       // 结束协程
```

#### 10.2 使用步骤

**步骤1**：配置定时基准
```c
set_timer_mode(Timer0, "1ms", Timer_End);
set_timer_isr(Timer0, set_task_mode);  // 设置协程时间基准
EA = 1;
```

**步骤2**：编写协程代码
```c
while(1)
{
    task_start(0);  // 协程0
        // 任务代码
        task_delay(100);  // 延时100ms
    task_end(1);  // 循环执行
}
```

#### 10.3 使用示例

```c
// 示例1：LED闪烁
int cnt = 0;

void main(void)
{
    EAXFR = 1; WTST = 0; CKCON = 0;
    set_io_mode(pp_mode, Pin00, Pin01, Pin02, Pin_End);
    set_timer_mode(Timer0, "1ms", Timer_End);
    set_timer_isr(Timer0, set_task_mode);
    EA = 1;
    
    while(1)
    {
        // 协程0：100ms闪烁
        task_start(0);
            P00 = ~P00;
            task_delay(100);
        task_end(1);
        
        // 协程1：200ms亮，500ms灭
        task_start(1);
            P01 = 0;
            task_delay(200);
            P01 = 1;
            task_delay(500);
        task_end(1);
        
        // 协程2：1秒后快闪3次，间隔300ms，循环
        task_start(2);
            task_delay(1000);
            task_for(cnt=0, cnt++) {
                P02 = ~P02;
                task_delay(50);
            }
            task_break(cnt < 6);  // 3次闪烁 = 6次翻转
            P02 = 0;
            task_delay(300);
        task_end(1);
    }
}

// 示例2：条件等待
task_start(3);
    P00 = ~P00;
    task_delay(100);
    task_wait(!P32);  // 等待P32为低电平
    // P32按下后才继续执行
task_end(1);

// 示例3：嵌套循环
int i, j;
task_start(4);
    task_for(i=0, i++) {
        task_for(j=0, j++) {
            P00 = ~P00;
            task_delay(50);
        }
        task_break(j < 3);
        task_delay(200);
    }
    task_break(i < 5);
task_end(1);

// 示例4：while循环
task_start(5);
    task_while(1) {
        P00 = ~P00;
        task_delay(100);
        task_break(P32 == 0);  // P32按下时退出
    }
    P00 = 0;  // 退出后熄灯
    task_delay(1000);
task_end(1);
```

#### 10.4 协程优势

✅ **轻量级**：每个协程仅占用6字节RAM  
✅ **非阻塞**：不影响其他任务执行  
✅ **易用性**：类C语法，学习曲线平缓  
✅ **高效率**：可同时运行10个协程（可扩展）

---

## 高级特性

### 1. 自动主频检测

库函数可自动检测HIRC内部时钟频率（外部晶振无法自动检测）：

```c
// 无需手动设置，自动适配STC-ISP配置的频率
// 如需手动设置：
set_timer_fosc(40000000);  // 40MHz
set_uart_fosc(40000000);
set_pwm_fosc(40000000);
```

### 2. 代码优化

使用 `Auto_Keil.exe` 工具自动优化：
- 移除未使用的IO组配置
- 优化EEPROM代码
- 代码体积减少高达269%

### 3. USB-CDC调试

支持通过USB直接调试，无需外置串口：
```c
#include "ai_usb.h"

usb_init();
EA = 1;

printf_usb("Temperature: %d\r\n", temp);
```

### 4. 中断扩展

支持标准中断和扩展中断号（需安装Keil插件）。

---

## 常见问题

### Q1: 如何选择定时器波特率发生器？

**A**: 多串口不同波特率时使用 `Use_Timerx`：
```c
set_uart_mode(Uart1, "115200bps", Use_Timerx, Uart_End);
set_uart_mode(Uart2, "9600bps", Use_Timerx, Uart_End);
```

### Q2: PWM周期配置冲突？

**A**: 同组PWM共享周期：
- Pwm1~4为PWMA组，配置Pwm1的周期会影响Pwm2~4
- Pwm5~8为PWMB组，同理

### Q3: I2C操作失败？

**A**: 检查以下事项：
1. IO配置为开漏 + 上拉电阻
2. 从设备地址正确（读地址=写地址+1）
3. 使用 `get_i2c_state()` 等待操作完成

### Q4: 协程延时不准确？

**A**: 确保：
1. 定时基准为1ms
2. 只有一个定时器调用 `set_task_mode`
3. 协程内不要使用阻塞延时

### Q5: EEPROM读取错误？

**A**: 原因可能是：
1. 变量绑定顺序改变
2. 首次使用需先 `Push` 再 `Pull`
3. EEPROM未擦除干净

### Q6: ADC值跳变？

**A**: 建议：
1. 添加硬件滤波电容
2. 软件多次采样取平均
3. 降低ADC时钟（修改 `ADC_DIV`）

### Q7: 串口乱码？

**A**: 检查：
1. 波特率设置正确
2. IO配置为准双向或推挽
3. 晶振频率与代码匹配

### Q8: 如何增加协程数量？

**A**: 修改 `set_task.h`：
```c
#define Task_Max_Num 20  // 改为20个协程
```

---

## 附录

### A. 引脚功能对照表

| 引脚 | 功能1 | 功能2 | 功能3 | 功能4 |
|------|-------|-------|-------|-------|
| P10 | GPIO | Adc0 | Pwm1P | T2 |
| P11 | GPIO | Adc1 | Pwm1N | T2CLKO |
| P14 | GPIO | Adc4 | Pwm3P | SPI0-SS |
| P15 | GPIO | Adc5 | Pwm3N | SPI0-MOSI |
| P20 | GPIO | - | - | T11 |
| P21 | GPIO | - | - | T11CLKO |
| P23 | GPIO | I2C-SDA | - | - |
| P24 | GPIO | I2C-SCL | - | - |
| P30 | GPIO | Uart1-RXD | - | - |
| P31 | GPIO | Uart1-TXD | - | - |
| P34 | GPIO | T1 | T1CLKO | - |
| P35 | GPIO | T0CLKO | - | - |

### B. 默认配置汇总

| 模块 | 默认值 |
|------|--------|
| 串口波特率 | 115200bps |
| 串口超时 | 64byte |
| 定时器周期 | 1s |
| PWM频率 | 1kHz |
| PWM占空比 | 50% |
| PWM死区 | 10clk |
| I2C速率 | 400kHz |
| SPI分频 | 16分频 |
| ADC分频 | 8分频 |

### C. 资源占用

| 示例 | CODE | XDATA | 说明 |
|------|------|-------|------|
| IO控制 | 2320 | 0 | 优化后 |
| 定时器 | 3500 | 10 | - |
| 串口 | 4200 | 240 | 含4路串口 |
| 协程 | 1800 | 60 | 10个协程 |
| 完整项目 | 15000 | 500 | 典型应用 |

### D. 版本历史

| 版本 | 日期 | 主要更新 |
|------|------|----------|
| V2.0 | 2025-05 | 新增DDS/MPU6050示例 |
| V1.9 | 2025-04 | 协程增强，支持while循环 |
| V1.8 | 2025-03 | 首次发布协程库 |
| V1.5 | 2025-02 | PWM输入捕获 |
| V1.0 | 2025-01 | 初始版本 |

### E. 参考资源

- **官方文档**: `库函数使用说明/AI8051U专属库函数使用文档.pdf`
- **建立项目**: `库函数使用说明/教程-如何建立一个项目.pdf`
- **独立例程**: `独立例程/` 目录下12个完整示例
- **更新记录**: `库函数更新记录.txt`

---

## 技术支持

如有问题，请参考：
1. 独立例程代码
2. PDF使用文档
3. 头文件内的详细注释

---

**文档结束**

*本文档基于AI8051U专用库函数V2.0编写，最后更新于2025年5月*

