# AI8051U 系统学习计划

> 从零基础到项目实战的完整学习路径

**制定日期**: 2025-10-11  
**预计周期**: 8-12 周（根据个人时间调整）  
**学习方式**: 理论 + 实践 + 项目

---

## 📋 学习计划总览

```
第一阶段 (2周)  → 入门基础：开发环境、GPIO、定时器、中断
第二阶段 (2周)  → 通信基础：UART、SPI、I2C
第三阶段 (2周)  → 模拟外设：ADC、PWM、比较器
第四阶段 (2周)  → 高级功能：DMA、USB、RTC、EEPROM
第五阶段 (2-4周) → 综合实战：多模块协同、项目开发
```

---

## 📅 第一阶段：入门基础（第 1-2 周）

### 🎯 学习目标
- 掌握开发环境的搭建和使用
- 理解 AI8051U 的基本架构
- 掌握 GPIO 的各种工作模式
- 学会使用定时器和中断

### 📚 理论学习

#### Day 1：环境搭建（2-3 小时）
**学习内容**：
- [ ] 安装 Keil C51 开发环境
- [ ] 安装 STC-ISP 下载工具
- [ ] 安装中断向量扩展插件
- [ ] 阅读 [README.md](./README.md) 了解项目结构

**参考文档**：
- [使用文档 - 第2章：开发环境搭建](./AI8051U-使用文档.md#2-开发环境搭建)

**实践任务**：
```
✓ 成功编译并下载第一个示例程序（01-IO-跑马灯）
✓ 观察 LED 跑马灯效果
✓ 修改延时参数，观察变化
```

---

#### Day 2：GPIO 基础（3-4 小时）
**学习内容**：
- [ ] GPIO 四种工作模式（准双向/高阻/开漏/推挽）
- [ ] GPIO 配置方法（宏定义 vs 结构体）
- [ ] 上拉/下拉电阻配置
- [ ] 驱动能力和速度设置

**参考文档**：
- [使用文档 - 第5章：GPIO模块](./AI8051U-使用文档.md#5-gpio-模块使用)
- [快速参考 - GPIO快速配置](./AI8051U-快速参考.md#gpio-快速配置)

**实践任务**：
```c
// 任务1：控制4个LED分别闪烁
// 任务2：实现流水灯效果（不同速度）
// 任务3：使用按键控制LED开关（带消抖）

// 代码模板
void main(void)
{
    System_Init();
    
    // 配置 P0 为推挽输出
    P0_MODE_OUT_PP(GPIO_Pin_All);
    
    // 配置 P3.2 为高阻输入（按键）
    P1_MODE_IN_HIZ(GPIO_Pin_0);
    P1_PULL_UP_ENABLE(GPIO_Pin_0);
    
    while(1)
    {
        if(P10 == 0)  // 按键检测
        {
            delay_ms(10);  // 消抖
            if(P10 == 0)
            {
                P00 = !P00;  // LED 翻转
                while(P10 == 0);  // 等待释放
            }
        }
    }
}
```

**学习重点**：
- ✅ 理解四种模式的应用场景
- ✅ 掌握按键消抖的原理和实现
- ✅ 学会使用宏定义快速配置

---

#### Day 3：定时器基础（3-4 小时）
**学习内容**：
- [ ] 定时器工作原理
- [ ] 定时时间计算方法
- [ ] 定时器中断配置
- [ ] 1T 和 12T 模式的区别

**参考文档**：
- [使用文档 - 第6章：定时器模块](./AI8051U-使用文档.md#6-定时器模块)
- [快速参考 - 定时器快速配置](./AI8051U-快速参考.md#定时器快速配置)

**实践任务**：
```c
// 任务1：使用 Timer0 实现 1ms 精确定时
// 任务2：基于定时器实现秒表功能（串口输出）
// 任务3：使用定时器产生 1kHz 方波

// 代码模板：1ms 定时中断
void Timer0_Init(void)
{
    TIM_InitTypeDef tim;
    
    tim.TIM_Mode = TIM_16BitAutoReload;
    tim.TIM_ClkSource = TIM_CLOCK_1T;
    tim.TIM_Value = 65536 - (MAIN_Fosc / 1000);  // 1ms
    tim.TIM_Run = ENABLE;
    
    Timer_Inilize(TIM_Timer0, &tim);
    NVIC_Timer0_Init(ENABLE, Priority_1);
    EA = 1;
}

volatile u16 sys_ms = 0;

void TM0_ISR(void) interrupt TMR0_VECTOR
{
    sys_ms++;
}
```

**计算练习**：
```
主频 40MHz，1T 模式：
- 定时 1ms： TIM_Value = 65536 - 40000 = 25536
- 定时 10ms：TIM_Value = 65536 - 400000（溢出，需分频）
- 定时 100us：TIM_Value = 65536 - 4000 = 61536
```

---

#### Day 4-5：外部中断（4-6 小时）
**学习内容**：
- [ ] 外部中断配置（INT0-INT4）
- [ ] 中断优先级设置
- [ ] GPIO 中断（P0-P7 端口中断）
- [ ] 中断嵌套

**参考文档**：
- [使用文档 - 5.4节：GPIO中断配置](./AI8051U-使用文档.md#54-gpio-中断配置)
- 示例：`独立程序/03-外中断INT0-INT1-INT2-INT3-INT4测试/`

**实践任务**：
```c
// 任务1：使用 INT0 实现按键中断
// 任务2：使用 GPIO 中断检测 8 个按键
// 任务3：实现不同优先级中断的响应

// 代码模板：外部中断
void INT0_Init(void)
{
    // 配置 P3.2 为高阻输入
    P3_MODE_IN_HIZ(GPIO_Pin_2);
    P3_PULL_UP_ENABLE(GPIO_Pin_2);
    
    // 配置下降沿触发
    IT0 = 1;  // 下降沿
    
    // 使能中断
    NVIC_INT0_Init(ENABLE, Priority_1);
    EA = 1;
}

void INT0_ISR(void) interrupt INT0_VECTOR
{
    // 处理中断
    LED_Toggle();
}
```

---

#### Day 6-7：阶段总结与小项目（6-8 小时）
**小项目 1：交通灯控制系统**
```
功能要求：
1. 使用 GPIO 控制 6 个 LED（红、黄、绿 x2）
2. 使用 Timer0 实现精确定时
3. 实现标准交通灯切换逻辑
4. 使用按键切换手动/自动模式
5. 串口输出当前状态

技能应用：
✓ GPIO 输入输出
✓ 定时器中断
✓ 外部中断（按键）
✓ 状态机设计
```

**代码框架**：
```c
typedef enum {
    STATE_NS_GREEN,   // 南北绿灯
    STATE_NS_YELLOW,  // 南北黄灯
    STATE_EW_GREEN,   // 东西绿灯
    STATE_EW_YELLOW   // 东西黄灯
} TrafficState_t;

TrafficState_t current_state = STATE_NS_GREEN;
u8 timer_count = 0;

void Timer0_ISR(void) interrupt TMR0_VECTOR
{
    static u16 cnt = 0;
    
    if(++cnt >= 1000)  // 1 秒
    {
        cnt = 0;
        timer_count++;
        
        // 状态切换逻辑
        switch(current_state)
        {
            case STATE_NS_GREEN:
                if(timer_count >= 30) {
                    current_state = STATE_NS_YELLOW;
                    timer_count = 0;
                }
                break;
            // ... 其他状态
        }
    }
}
```

---

### ✅ 第一阶段考核

完成以下任务即可进入下一阶段：

- [ ] 能够独立搭建开发环境
- [ ] 理解并正确配置 GPIO 四种模式
- [ ] 能够计算定时器定时值
- [ ] 能够配置和使用外部中断
- [ ] 完成交通灯小项目

**评估标准**：
- 代码能够正常编译运行 ✓
- 理解每行代码的作用 ✓
- 能够独立修改和调试 ✓

---

## 📅 第二阶段：通信基础（第 3-4 周）

### 🎯 学习目标
- 掌握串口通信原理和应用
- 学会使用 SPI 接口访问外设
- 掌握 I2C 主机和从机模式
- 理解通信协议设计

### 📚 理论学习

#### Day 8-9：UART 串口通信（6-8 小时）
**学习内容**：
- [ ] 串口通信原理（起始位、数据位、停止位、校验位）
- [ ] 波特率计算和配置
- [ ] 中断收发 vs 查询收发
- [ ] Printf 重定向

**参考文档**：
- [使用文档 - 第7章：串口通信](./AI8051U-使用文档.md#7-串口通信-uart)
- 示例：`独立程序/05-串口1中断模式与电脑收发测试/`

**实践任务**：
```c
// 任务1：实现串口回显（接收什么发送什么）
// 任务2：实现简单的命令解析（LED 控制）
// 任务3：使用 Printf 输出调试信息

// 代码模板：串口初始化
void UART1_Init(void)
{
    COMx_InitDefine com;
    
    com.UART_Mode = UART_8bit_BRTx;
    com.UART_BRT_Use = BRT_Timer1;
    com.UART_BaudRate = 115200;
    com.UART_RxEnable = ENABLE;
    com.ParityMode = PARITY_NONE;
    
    UART_Configuration(UART1, &com);
    NVIC_UART1_Init(ENABLE, Priority_1);
    EA = 1;
}

// 中断接收
void UART1_ISR(void) interrupt UART1_VECTOR
{
    if(RI)
    {
        CLR_RI();
        u8 dat = SBUF;
        RX_Buffer[RX_Cnt++] = dat;
        
        if(dat == '\n')  // 接收到换行符
        {
            RX_Flag = 1;  // 设置接收完成标志
        }
    }
    
    if(TI)
    {
        CLR_TI();
        // 发送下一个字节
    }
}
```

**命令解析示例**：
```c
// 命令格式：LED1_ON, LED1_OFF, LED2_ON, LED2_OFF
void Parse_Command(u8 *cmd)
{
    if(strcmp(cmd, "LED1_ON") == 0)
    {
        P00 = 0;
        printf("LED1 ON\r\n");
    }
    else if(strcmp(cmd, "LED1_OFF") == 0)
    {
        P00 = 1;
        printf("LED1 OFF\r\n");
    }
    // ... 更多命令
}
```

**波特率计算练习**：
```
主频 40MHz，Timer1，8位自动重载：
- 115200：TH1 = TL1 = 256 - (40000000/115200/32) = 245 (0xF5)
- 9600：  TH1 = TL1 = 256 - (40000000/9600/32) = 126 (0x7E)

主频 11.0592MHz（标准频率），9600：
- TH1 = TL1 = 256 - (11059200/9600/32) = 220 (0xDC)
```

---

#### Day 10-11：SPI 通信（6-8 小时）
**学习内容**：
- [ ] SPI 通信原理（MOSI、MISO、SCLK、CS）
- [ ] SPI 四种模式（CPOL、CPHA）
- [ ] 主从模式配置
- [ ] Flash 芯片操作（W25Q64）

**参考文档**：
- [使用文档 - 第10章：SPI通信](./AI8051U-使用文档.md#10-spi-通信)
- 示例：`独立程序/20.1-串口发指令通过SPI访问Flash芯片/`

**实践任务**：
```c
// 任务1：读取 W25Q64 的设备 ID
// 任务2：向 Flash 写入数据并读回验证
// 任务3：实现扇区擦除和页编程

// 代码模板：SPI 初始化
void SPI_Init(void)
{
    SPI_InitTypeDef spi;
    
    spi.SPI_Module = SPI_Module_SPI;
    spi.SPI_Mode = SPI_Mode_Master;
    spi.SPI_CPOL = SPI_CPOL_Low;
    spi.SPI_CPHA = SPI_CPHA_1Edge;
    spi.SPI_Speed = SPI_Speed_4;
    spi.SPI_Enable = ENABLE;
    
    SPI_Inilize(&spi);
    
    // GPIO 配置
    P1_MODE_OUT_PP(GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4);
    P1_MODE_IN_HIZ(GPIO_Pin_5);
}

// W25Q64 读 ID
u16 W25Q64_Read_ID(void)
{
    u16 id;
    
    CS = 0;
    SPI_Transfer(0x90);  // Read ID 命令
    SPI_Transfer(0x00);
    SPI_Transfer(0x00);
    SPI_Transfer(0x00);
    id = SPI_Transfer(0xFF) << 8;
    id |= SPI_Transfer(0xFF);
    CS = 1;
    
    return id;  // 应返回 0xEF16
}
```

**W25Q64 操作流程**：
```
1. 读 ID → 验证通信正常
2. 写使能 → 0x06 命令
3. 扇区擦除 → 0x20 命令 + 地址
4. 页编程 → 0x02 命令 + 地址 + 数据（最多 256 字节）
5. 读数据 → 0x03 命令 + 地址
```

---

#### Day 12-13：I2C 通信（6-8 小时）
**学习内容**：
- [ ] I2C 通信原理（起始、地址、应答、停止）
- [ ] I2C 主机模式配置
- [ ] I2C 从机模式配置
- [ ] EEPROM 操作（AT24C02）

**参考文档**：
- [使用文档 - 第11章：I2C通信](./AI8051U-使用文档.md#11-i2c-通信)
- 示例：`独立程序/15.1-I2C主机模式访问AT24C02程序/`

**实践任务**：
```c
// 任务1：读写 AT24C02 单个字节
// 任务2：连续读写多个字节
// 任务3：实现 I2C 从机模式（两块板通信）

// 代码模板：I2C 主机初始化
void I2C_Master_Init(void)
{
    I2C_InitTypeDef i2c;
    
    i2c.I2C_Mode = I2C_Mode_Master;
    i2c.I2C_Enable = ENABLE;
    i2c.I2C_Speed = 400000;  // 400kHz
    
    I2C_Init(&i2c);
    
    // GPIO 配置（开漏 + 上拉）
    P1_MODE_OUT_OD(GPIO_Pin_6 | GPIO_Pin_7);
    P1_PULL_UP_ENABLE(GPIO_Pin_6 | GPIO_Pin_7);
}

// AT24C02 写字节
void AT24C02_Write_Byte(u8 addr, u8 dat)
{
    I2C_Start();
    I2C_Write_Byte(0xA0);      // 器件地址 + 写
    I2C_Write_Byte(addr);       // 字节地址
    I2C_Write_Byte(dat);        // 数据
    I2C_Stop();
    delay_ms(5);                // 等待写入完成
}

// AT24C02 读字节
u8 AT24C02_Read_Byte(u8 addr)
{
    u8 dat;
    
    I2C_Start();
    I2C_Write_Byte(0xA0);       // 器件地址 + 写
    I2C_Write_Byte(addr);       // 字节地址
    
    I2C_Start();                // 重新开始
    I2C_Write_Byte(0xA1);       // 器件地址 + 读
    dat = I2C_Read_Byte(0);     // 读数据（NACK）
    I2C_Stop();
    
    return dat;
}
```

---

#### Day 14：阶段总结与小项目（8 小时）
**小项目 2：智能数据记录器**
```
功能要求：
1. 通过串口接收命令
2. 将数据存储到 W25Q64 Flash
3. 将配置参数存储到 AT24C02 EEPROM
4. 支持数据查询和导出
5. 显示存储状态（串口或 LED）

技能应用：
✓ UART 命令解析
✓ SPI Flash 操作
✓ I2C EEPROM 操作
✓ 数据管理和协议设计
```

**命令示例**：
```
WRITE <addr> <data>     - 写入数据到 Flash
READ <addr> <len>       - 从 Flash 读取数据
ERASE <sector>          - 擦除 Flash 扇区
CONFIG <param> <value>  - 设置配置参数（保存到 EEPROM）
STATUS                  - 查询存储状态
```

---

### ✅ 第二阶段考核

- [ ] 能够配置和使用串口通信
- [ ] 能够计算不同波特率的定时器值
- [ ] 掌握 SPI 接口操作 Flash 芯片
- [ ] 掌握 I2C 接口操作 EEPROM
- [ ] 完成数据记录器小项目

---

## 📅 第三阶段：模拟外设（第 5-6 周）

### 🎯 学习目标
- 掌握 ADC 采样和数据处理
- 学会使用 PWM 控制电机和 LED
- 理解比较器的应用
- 掌握模拟信号处理技巧

### 📚 理论学习

#### Day 15-16：ADC 模拟采样（6-8 小时）
**学习内容**：
- [ ] ADC 工作原理
- [ ] ADC 分辨率和采样速度
- [ ] 电压转换计算
- [ ] BandGap 基准电压测量
- [ ] 多次采样滤波

**参考文档**：
- [使用文档 - 第8章：ADC模块](./AI8051U-使用文档.md#8-adc-模块)
- 示例：`独立程序/10-多路ADC转换-串口输出结果/`

**实践任务**：
```c
// 任务1：采样电位器电压并串口输出
// 任务2：测量内部 BandGap，计算实际 VCC
// 任务3：实现温度传感器读取（NTC 或 LM35）

// 代码模板：ADC 初始化
void ADC_Init(void)
{
    ADC_InitTypeDef adc;
    
    adc.ADC_Channels = ADC_CH0 | ADC_CH1;
    adc.ADC_Speed = ADC_SPEED_2X16T;
    adc.ADC_Power = ENABLE;
    adc.ADC_AdjResult = ADC_RIGHT_JUSTIFIED;
    
    ADC_Inilize(&adc);
    
    // GPIO 必须配置为高阻输入
    P1_MODE_IN_HIZ(GPIO_Pin_0 | GPIO_Pin_1);
}

// ADC 采样
u16 ADC_Read(u8 channel)
{
    ADC_CONTR = (ADC_CONTR & 0xF0) | channel;
    ADC_START = 1;
    _nop_(); _nop_(); _nop_(); _nop_();
    while(!ADC_FLAG);
    ADC_FLAG = 0;
    return (ADC_RES << 8) | ADC_RESL;
}

// 多次采样求平均（滤波）
u16 ADC_Read_Average(u8 channel, u8 times)
{
    u32 sum = 0;
    u8 i;
    
    for(i=0; i<times; i++)
    {
        sum += ADC_Read(channel);
        delay_ms(5);
    }
    
    return sum / times;
}

// 电压转换（12位ADC，VCC=5000mV）
u16 ADC_To_Voltage(u16 adc_val)
{
    return (u32)adc_val * 5000 / 4096;
}
```

**温度测量示例（LM35）**：
```c
// LM35：10mV/°C
float Get_Temperature(void)
{
    u16 adc_val = ADC_Read_Average(ADC_CH0, 10);
    u16 voltage = ADC_To_Voltage(adc_val);
    
    // 温度 = 电压(mV) / 10
    return voltage / 10.0;
}
```

---

#### Day 17-18：PWM 脉宽调制（6-8 小时）
**学习内容**：
- [ ] PWM 工作原理
- [ ] PWM 频率和占空比计算
- [ ] 呼吸灯效果实现
- [ ] 电机调速控制
- [ ] 互补 PWM 输出（电机驱动）

**参考文档**：
- [使用文档 - 第9章：PWM模块](./AI8051U-使用文档.md#9-pwm-模块)
- 示例：`独立程序/17-高级PWM1-PWM2-PWM3-PWM4驱动P0口呼吸灯实验程序/`

**实践任务**：
```c
// 任务1：实现 LED 呼吸灯效果
// 任务2：通过串口控制 PWM 占空比
// 任务3：实现直流电机调速

// 代码模板：PWM 初始化
void PWM_Init(void)
{
    PWMx_InitDefine pwm;
    
    pwm.PWM_Mode = CCMRn_PWM_MODE1;
    pwm.PWM_Duty = 10000;               // 初始占空比 50%
    pwm.PWM_EnoSelect = ENO_PWM1P;
    pwm.PWM_Period = 20000;             // 频率 2kHz（40MHz/20000）
    pwm.PWM_DeadTime = 0;
    pwm.PWM_MainOutEnable = ENABLE;
    pwm.PWM_CEN_Enable = ENABLE;
    
    PWMx_Configuration(PWM1, &pwm);
    
    P2_MODE_OUT_PP(GPIO_Pin_0);
}

// 设置占空比（0-100%）
void PWM_Set_Duty(u8 percent)
{
    u16 duty = (u32)20000 * percent / 100;
    PWMA_CCR1H = duty >> 8;
    PWMA_CCR1L = duty;
}

// 呼吸灯效果
void Breathing_LED(void)
{
    u8 i;
    
    while(1)
    {
        // 渐亮
        for(i=0; i<=100; i++)
        {
            PWM_Set_Duty(i);
            delay_ms(10);
        }
        
        // 渐灭
        for(i=100; i>0; i--)
        {
            PWM_Set_Duty(i);
            delay_ms(10);
        }
    }
}
```

**电机调速示例**：
```c
// 电机速度控制（0-100）
void Motor_Set_Speed(u8 speed)
{
    if(speed > 100) speed = 100;
    PWM_Set_Duty(speed);
}

// 电机方向控制（使用 H 桥）
void Motor_Set_Direction(bit forward)
{
    if(forward)
    {
        P20 = 1;  // IN1
        P21 = 0;  // IN2
    }
    else
    {
        P20 = 0;
        P21 = 1;
    }
}
```

---

#### Day 19：比较器应用（4 小时）
**学习内容**：
- [ ] 比较器工作原理
- [ ] 基准电压设置
- [ ] 比较器中断
- [ ] 过压/欠压检测

**参考文档**：
- [使用文档 - 14.4节：比较器](./AI8051U-使用文档.md#144-比较器)
- 示例：`独立程序/13-利用P4.6做比较器正极输入源/`

**实践任务**：
```c
// 任务：实现电压监测报警

void Comparator_Init(void)
{
    CMP_InitTypeDef cmp;
    
    cmp.CMP_EN = ENABLE;
    cmp.CMP_P_Select = CMP_P_SEL_P46;        // P4.6 作正输入
    cmp.CMP_N_Select = CMP_N_SEL_VREF;       // 1.19V 作负输入
    cmp.CMP_RiseIntEnable = ENABLE;          // 上升沿中断
    cmp.CMP_Polity = Priority_1;
    
    CMP_Inilize(&cmp);
}

void CMP_ISR(void) interrupt CMP_VECTOR
{
    if(CMPIF)
    {
        CMPIF = 0;
        
        if(CMPRES)  // P4.6 > 1.19V
        {
            printf("警告：电压过高！\r\n");
            LED_Warning();
        }
    }
}
```

---

#### Day 20-21：阶段总结与小项目（6-8 小时）
**小项目 3：智能风扇控制系统**
```
功能要求：
1. 使用 ADC 读取温度传感器
2. 根据温度自动调节风扇速度（PWM）
3. 串口显示当前温度和风扇转速
4. 支持手动模式（串口设置转速）
5. 过温报警（比较器或软件判断）
6. 温度曲线记录（存储到 Flash）

技能应用：
✓ ADC 温度采样
✓ PWM 电机控制
✓ 自动控制算法
✓ 串口人机交互
✓ 数据存储
```

**控制算法示例**：
```c
// PID 控制或分段控制
u8 Calculate_Fan_Speed(float temp)
{
    u8 speed;
    
    if(temp < 25)
        speed = 0;         // 停止
    else if(temp < 30)
        speed = 30;        // 低速
    else if(temp < 35)
        speed = 60;        // 中速
    else
        speed = 100;       // 高速
    
    return speed;
}

void main(void)
{
    System_Init();
    ADC_Init();
    PWM_Init();
    UART1_Init();
    
    while(1)
    {
        float temp = Get_Temperature();
        u8 speed = Calculate_Fan_Speed(temp);
        
        Motor_Set_Speed(speed);
        
        printf("Temperature: %.1f°C, Speed: %d%%\r\n", temp, speed);
        
        delay_ms(1000);
    }
}
```

---

### ✅ 第三阶段考核

- [ ] 能够正确使用 ADC 采样和数据处理
- [ ] 掌握 PWM 频率和占空比计算
- [ ] 能够实现自动控制算法
- [ ] 完成智能风扇控制系统

---

## 📅 第四阶段：高级功能（第 7-8 周）

### 🎯 学习目标
- 掌握 DMA 加速数据传输
- 学会使用 USB 功能
- 理解 RTC 和 EEPROM 应用
- 掌握低功耗设计

### 📚 理论学习

#### Day 22-23：DMA 直接内存访问（6-8 小时）
**学习内容**：
- [ ] DMA 工作原理
- [ ] DMA 通道配置
- [ ] DMA + ADC 连续采样
- [ ] DMA + UART 高速传输
- [ ] DMA + SPI 块传输

**参考文档**：
- [使用文档 - 第12章：DMA模块](./AI8051U-使用文档.md#12-dma-模块)
- 示例：`独立程序/21-ADC采样数据自动存入DMA-串口输出结果/`

**实践任务**：
```c
// 任务1：使用 DMA+ADC 连续采样 256 点
// 任务2：使用 DMA+UART 发送大量数据
// 任务3：使用 DMA 进行内存拷贝

// 代码模板：DMA + ADC
u16 xdata adc_buf[256];

void DMA_ADC_Init(void)
{
    // ADC 配置
    ADC_InitTypeDef adc;
    adc.ADC_Channels = ADC_CH0;
    adc.ADC_Speed = ADC_SPEED_2X16T;
    adc.ADC_Power = ENABLE;
    ADC_Inilize(&adc);
    
    // DMA 配置
    DMA_ADC_InitTypeDef dma;
    dma.DMA_Enable = ENABLE;
    dma.DMA_Channel = DMA_ADC_Channel;
    dma.DMA_DST_Addr = (u16)adc_buf;
    dma.DMA_Length = 256;
    dma.DMA_INT_Enable = ENABLE;
    
    DMA_ADC_Inilize(&dma);
    
    // 启动 DMA
    DMA_ADC_CR |= 0x80;
}

// DMA 完成中断
void DMA_ADC_ISR(void) interrupt DMA_ADC_VECTOR
{
    DMA_ADC_STA = 0;
    
    // 处理采样数据
    printf("ADC DMA Done! 256 samples collected\r\n");
    
    // 计算平均值
    u32 sum = 0;
    u16 i;
    for(i=0; i<256; i++)
        sum += adc_buf[i];
    
    u16 avg = sum / 256;
    printf("Average: %d\r\n", avg);
}
```

---

#### Day 24-25：USB 功能（6-8 小时）
**学习内容**：
- [ ] USB 通信原理
- [ ] USB CDC（虚拟串口）
- [ ] USB HID（键盘/鼠标）
- [ ] USB 枚举过程

**参考文档**：
- [使用文档 - 第13章：USB功能](./AI8051U-使用文档.md#13-usb-功能)
- 示例：`综合程序/App/src/APP_USB.c`

**实践任务**：
```c
// 任务1：实现 USB 虚拟串口
// 任务2：实现 USB 键盘（发送按键）
// 任务3：USB 数据传输性能测试

// 代码模板：USB CDC
void USB_CDC_Init(void)
{
    // 配置 USB 时钟（48MHz）
    IRC48MCR = 0x80;
    while(!(IRC48MCR & 0x01));
    
    USBCLK = 0x00;
    
    // 使能 USB
    ENUSB = 1;
    
    // USB 库初始化
    usb_init();
}

void main(void)
{
    System_Init();
    USB_CDC_Init();
    
    while(1)
    {
        usb_process();  // 处理 USB 事务
        
        // 发送数据
        if(usb_cdc_connected())
        {
            char msg[] = "Hello USB!\r\n";
            usb_cdc_send(msg, strlen(msg));
        }
        
        // 接收数据
        if(usb_cdc_available())
        {
            u8 dat = usb_cdc_read();
            // 处理接收数据
        }
        
        delay_ms(1000);
    }
}
```

---

#### Day 26：EEPROM 和 RTC（4 小时）
**学习内容**：
- [ ] 内部 EEPROM 操作
- [ ] RTC 时钟配置
- [ ] 掉电保存数据

**参考文档**：
- [使用文档 - 14.1节：EEPROM](./AI8051U-使用文档.md#141-eeprom-操作)
- [使用文档 - 14.2节：RTC](./AI8051U-使用文档.md#142-rtc-实时时钟)

**实践任务**：
```c
// 任务1：保存系统配置到 EEPROM
// 任务2：实现电子时钟（RTC + 串口显示）

// EEPROM 操作
#define CONFIG_ADDR  0x0000

typedef struct {
    u8 mode;
    u8 brightness;
    u16 checksum;
} Config_t;

void Save_Config(Config_t *cfg)
{
    u8 *p = (u8*)cfg;
    u16 addr = CONFIG_ADDR;
    u8 i;
    
    for(i=0; i<sizeof(Config_t); i++)
    {
        EEPROM_Write_Byte(addr++, *p++);
    }
}

void Load_Config(Config_t *cfg)
{
    u8 *p = (u8*)cfg;
    u16 addr = CONFIG_ADDR;
    u8 i;
    
    for(i=0; i<sizeof(Config_t); i++)
    {
        *p++ = EEPROM_Read_Byte(addr++);
    }
}

// RTC 电子时钟
void RTC_Init(void)
{
    RTC_InitTypeDef rtc;
    
    rtc.RTC_ClkSel = RTC_CLK_SEL_IRC32K;
    rtc.RTC_Year = 25;      // 2025
    rtc.RTC_Month = 10;
    rtc.RTC_Day = 11;
    rtc.RTC_Hour = 12;
    rtc.RTC_Minute = 0;
    rtc.RTC_Second = 0;
    
    RTC_Inilize(&rtc);
}

void Display_Time(void)
{
    printf("20%02d-%02d-%02d %02d:%02d:%02d\r\n",
           YEAR, MONTH, DAY, HOUR, MIN, SEC);
}
```

---

#### Day 27-28：阶段总结与小项目（6-8 小时）
**小项目 4：USB 数据采集系统**
```
功能要求：
1. 使用 USB CDC 与电脑通信
2. DMA + ADC 高速采样（1000 samples/s）
3. 实时传输数据到电脑
4. RTC 时间戳记录
5. EEPROM 保存配置参数
6. 低功耗模式支持

技能应用：
✓ USB 通信
✓ DMA 高速传输
✓ ADC 连续采样
✓ RTC 时间管理
✓ EEPROM 数据保存
✓ 低功耗设计
```

---

### ✅ 第四阶段考核

- [ ] 理解 DMA 原理并正确配置
- [ ] 能够使用 USB CDC 通信
- [ ] 掌握 EEPROM 和 RTC 应用
- [ ] 完成 USB 数据采集系统

---

## 📅 第五阶段：综合实战（第 9-12 周）

### 🎯 学习目标
- 学习专业项目架构设计
- 掌握多模块协同开发
- 理解状态机和任务调度
- 完成完整的实战项目

### 📚 学习内容

#### Week 9：项目架构学习（1 周）
**学习任务**：
- [ ] 分析综合程序的架构设计
- [ ] 理解分层设计思想（Driver / App / User）
- [ ] 学习任务调度机制
- [ ] 掌握模块化开发方法

**参考代码**：
```
综合程序/
├── Driver/     # 驱动层
├── App/        # 应用层
├── User/       # 用户层
    ├── main.c
    ├── Task.c/h
    └── System_init.c/h
```

**重点学习**：
```c
// 任务调度框架
void Task_Handler(void)
{
    if(Task_1ms_Flag)
    {
        Task_1ms_Flag = 0;
        Task_1ms();      // 高优先级任务
    }
    
    if(Task_10ms_Flag)
    {
        Task_10ms_Flag = 0;
        Task_10ms();     // 常规任务
    }
    
    if(Task_100ms_Flag)
    {
        Task_100ms_Flag = 0;
        Task_100ms();    // 较慢任务
    }
}
```

---

#### Week 10-11：实战项目开发（2 周）
**大项目选择**（选择其一）：

### 项目 A：智能环境监测站
```
硬件需求：
- 温湿度传感器（DHT11/SHT30）
- 光照传感器（BH1750）
- 气压传感器（BMP280）
- OLED 显示屏
- W25Q64 Flash
- USB 接口

功能要求：
1. 多传感器数据采集（I2C/单总线）
2. OLED 实时显示
3. 数据记录到 Flash（每分钟一次）
4. USB 导出历史数据
5. 异常报警（温度/湿度超限）
6. 低功耗设计（休眠唤醒）
7. RTC 时间戳
8. 配置参数保存（EEPROM）
```

### 项目 B：多功能示波器（简易版）
```
硬件需求：
- ADC 输入（信号调理电路）
- OLED 显示屏
- 按键（4个）
- USB 接口
- W25Q64 Flash

功能要求：
1. DMA + ADC 高速采样
2. 波形显示（OLED）
3. 触发模式（上升沿/下降沿）
4. 时基调节（采样率）
5. 电压测量和显示
6. 波形存储和回放
7. USB 数据导出
8. 参数设置菜单
```

### 项目 C：无线传感器网络节点
```
硬件需求：
- NRF24L01（SPI 无线模块）
- 多种传感器
- OLED 显示
- 锂电池供电
- USB 充电

功能要求：
1. SPI 无线通信
2. 传感器数据采集
3. 组网协议实现
4. 低功耗设计
5. 数据加密
6. 本地显示
7. USB 配置接口
8. 电池电量管理
```

---

#### Week 12：项目优化与总结（1 周）
**优化方向**：
- [ ] 代码优化（降低内存占用）
- [ ] 性能优化（提高响应速度）
- [ ] 功耗优化（延长续航）
- [ ] 可靠性优化（异常处理）
- [ ] 用户体验优化（人机交互）

**文档编写**：
- [ ] 项目说明文档
- [ ] 用户使用手册
- [ ] 开发笔记整理
- [ ] 演示视频制作

---

## 📊 学习评估标准

### 入门级（第 1-2 周结束）
- ✅ 能够搭建开发环境
- ✅ 理解基本的 GPIO 操作
- ✅ 能够使用定时器和中断
- ✅ 能够运行和修改示例代码

### 进阶级（第 3-4 周结束）
- ✅ 掌握串口通信协议
- ✅ 能够操作 SPI 和 I2C 外设
- ✅ 能够设计简单的通信协议
- ✅ 能够独立完成小项目

### 高级级（第 5-6 周结束）
- ✅ 掌握 ADC 采样和数据处理
- ✅ 能够使用 PWM 实现控制
- ✅ 理解模拟信号处理
- ✅ 能够实现闭环控制

### 专家级（第 7-8 周结束）
- ✅ 掌握 DMA 高级应用
- ✅ 能够使用 USB 功能
- ✅ 理解低功耗设计
- ✅ 能够优化系统性能

### 工程级（第 9-12 周结束）
- ✅ 理解项目架构设计
- ✅ 能够进行模块化开发
- ✅ 掌握多任务调度
- ✅ 能够独立完成复杂项目

---

## 📚 学习资源

### 官方文档
- [ ] AI8051U 数据手册
- [ ] AI8051U 库函数使用说明.pdf
- [ ] Keil C51 用户手册

### 项目文档
- [ ] [README.md](./README.md)
- [ ] [AI8051U-使用文档.md](./AI8051U-使用文档.md)
- [ ] [AI8051U-快速参考.md](./AI8051U-快速参考.md)
- [ ] [项目模板-快速开始.md](./项目模板-快速开始.md)
- [ ] [文档索引.md](./文档索引.md)

### 示例代码
- [ ] 29 个独立程序示例
- [ ] 综合程序（完整架构）

---

## 💡 学习建议

### 学习方法
1. **理论先行** - 先理解原理再动手
2. **实践为主** - 每天至少 2 小时实际编程
3. **循序渐进** - 不跳跃，稳扎稳打
4. **记录总结** - 写学习笔记和代码注释
5. **遇问题先思考** - 培养独立解决问题的能力

### 时间安排建议
- **工作日**: 每天 2-3 小时
- **周末**: 每天 4-6 小时
- **灵活调整**: 根据个人情况调整进度

### 学习技巧
1. **多看示例** - 参考 29 个示例程序
2. **多做实验** - 修改参数观察效果
3. **多写注释** - 帮助理解和记忆
4. **多查文档** - 使用文档索引快速查找
5. **多做项目** - 将知识整合应用

---

## ✅ 学习检查清单

### 每日检查
- [ ] 完成今天的学习任务
- [ ] 运行并理解今天的代码
- [ ] 记录学习笔记
- [ ] 完成实践任务

### 每周检查
- [ ] 完成本周所有任务
- [ ] 通过阶段考核
- [ ] 完成小项目
- [ ] 总结本周收获

### 每月检查
- [ ] 回顾所学知识
- [ ] 梳理知识体系
- [ ] 更新学习计划
- [ ] 评估学习效果

---

## 🎓 结业标准

完成以下要求即可结业：

### 理论知识
- ✅ 理解 AI8051U 的架构和特性
- ✅ 掌握所有外设的工作原理
- ✅ 理解通信协议和数据处理
- ✅ 掌握低功耗设计方法

### 实践能力
- ✅ 能够独立完成项目开发
- ✅ 能够设计合理的系统架构
- ✅ 能够调试和解决问题
- ✅ 能够优化代码性能

### 项目经验
- ✅ 完成至少 3 个小项目
- ✅ 完成 1 个综合大项目
- ✅ 编写完整的项目文档
- ✅ 能够演示和讲解项目

---

## 📞 学习支持

### 技术支持
- 🌐 STC 官方网站：www.stcai.com
- 📚 官方论坛：STC 单片机论坛
- 📧 技术支持：联系 STC 官方

### 学习交流
建议加入相关技术社区，与其他学习者交流经验。

---

## 📈 进阶方向

完成本学习计划后，可以继续学习：

1. **RTOS 应用** - FreeRTOS / RT-Thread
2. **通信协议** - Modbus / CAN / LIN
3. **图形界面** - LVGL / EmWin
4. **算法优化** - 信号处理 / 控制算法
5. **物联网应用** - MQTT / CoAP
6. **产品化开发** - EMC / 认证 / 量产

---

## 🎯 最后的话

学习是一个循序渐进的过程，不要急于求成。遇到困难是正常的，重要的是：

- **坚持** - 每天进步一点点
- **实践** - 动手才能真正掌握
- **思考** - 理解原理而非死记硬背
- **总结** - 将知识系统化

**祝你学习顺利，早日成为 AI8051U 开发高手！** 🚀

---

<p align="center">
  <b>开始你的 AI8051U 学习之旅吧！</b><br>
  <sub>Stay hungry, Stay foolish!</sub>
</p>

