# AI8051U 项目模板 - 快速开始

> 5 分钟创建你的第一个 AI8051U 项目

---

## 📋 模板 1：最小系统模板

适合：快速验证想法、简单测试

### 文件结构
```
MyProject/
├── main.c              # 主程序
├── AI8051U_GPIO.c/h    # GPIO 驱动
├── AI8051U_Delay.c/h   # 延时函数
├── AI8051U.H           # 寄存器定义
├── config.h            # 配置文件
└── MyProject.uvproj    # Keil 工程
```

### main.c 模板

```c
/*******************************************************************************
 * 项目名称: MyProject
 * 文件名称: main.c
 * 创建日期: 2025-XX-XX
 * 作者: Your Name
 * 功能描述: 项目主程序
 ******************************************************************************/

#include "config.h"
#include "AI8051U_GPIO.h"
#include "AI8051U_Delay.h"

/*******************************************************************************
 * 函数声明
 ******************************************************************************/
void System_Init(void);
void GPIO_Init(void);

/*******************************************************************************
 * 主程序
 ******************************************************************************/
void main(void)
{
    // 系统初始化
    System_Init();
    
    // 外设初始化
    GPIO_Init();
    
    // 主循环
    while(1)
    {
        // 你的代码在这里
        P00 = 0;        // LED 亮
        delay_ms(500);
        P00 = 1;        // LED 灭
        delay_ms(500);
    }
}

/*******************************************************************************
 * 函数名称: System_Init
 * 函数功能: 系统初始化
 * 输入参数: 无
 * 返回值: 无
 ******************************************************************************/
void System_Init(void)
{
    WTST = 0;        // CPU 最高速
    EAXSFR();        // 使能扩展寄存器
    CKCON = 0;       // XRAM 高速访问
    SET_TPS();       // 设置时间单位
    
    EA = 1;          // 使能总中断
}

/*******************************************************************************
 * 函数名称: GPIO_Init
 * 函数功能: GPIO 初始化
 * 输入参数: 无
 * 返回值: 无
 ******************************************************************************/
void GPIO_Init(void)
{
    P0_MODE_OUT_PP(GPIO_Pin_0);  // P0.0 推挽输出
}
```

---

## 📋 模板 2：串口调试模板

适合：需要串口输出调试信息的项目

### 文件结构
```
MyProject/
├── main.c
├── AI8051U_GPIO.c/h
├── AI8051U_UART.c/h
├── AI8051U_UART_Isr.c
├── AI8051U_NVIC.c/h
├── AI8051U.H
├── config.h
└── MyProject.uvproj
```

### main.c 模板

```c
#include "config.h"
#include "AI8051U_GPIO.h"
#include "AI8051U_UART.h"

void System_Init(void);
void GPIO_Init(void);
void UART_Init(void);

void main(void)
{
    System_Init();
    GPIO_Init();
    UART_Init();
    
    // 启动信息
    printf("\r\n");
    printf("========================================\r\n");
    printf(" Project: MyProject\r\n");
    printf(" Version: V1.0\r\n");
    printf(" Date: 2025-XX-XX\r\n");
    printf("========================================\r\n");
    
    while(1)
    {
        // 打印调试信息
        printf("System Running...\r\n");
        delay_ms(1000);
    }
}

void System_Init(void)
{
    WTST = 0;
    EAXSFR();
    CKCON = 0;
    SET_TPS();
    EA = 1;
}

void GPIO_Init(void)
{
    P0_MODE_OUT_PP(GPIO_Pin_0);
}

void UART_Init(void)
{
    COMx_InitDefine com;
    
    com.UART_Mode = UART_8bit_BRTx;
    com.UART_BRT_Use = BRT_Timer1;
    com.UART_BaudRate = 115200;
    com.UART_RxEnable = ENABLE;
    com.BaudRateDouble = DISABLE;
    com.ParityMode = PARITY_NONE;
    
    UART_Configuration(UART1, &com);
    NVIC_UART1_Init(ENABLE, Priority_1);
}
```

---

## 📋 模板 3：多任务调度模板

适合：复杂项目，多个任务并行

### 文件结构
```
MyProject/
├── main.c              # 主程序
├── task.c/h            # 任务调度
├── system.c/h          # 系统初始化
├── hardware/           # 硬件驱动层
│   ├── led.c/h
│   ├── key.c/h
│   └── uart.c/h
├── driver/             # 芯片驱动层
│   ├── AI8051U_*.c/h
│   └── ...
└── MyProject.uvproj
```

### main.c

```c
#include "config.h"
#include "system.h"
#include "task.h"

void main(void)
{
    // 系统初始化
    System_Init();
    
    // 启动消息
    printf("System Start!\r\n");
    
    // 主循环 - 任务调度
    while(1)
    {
        Task_Handler();  // 任务处理
    }
}
```

### task.h

```c
#ifndef __TASK_H__
#define __TASK_H__

#include "config.h"

// 任务标志
extern bit Task_1ms_Flag;
extern bit Task_10ms_Flag;
extern bit Task_100ms_Flag;
extern bit Task_1s_Flag;

// 任务函数
void Task_Handler(void);
void Task_1ms(void);
void Task_10ms(void);
void Task_100ms(void);
void Task_1s(void);

#endif
```

### task.c

```c
#include "task.h"

// 任务标志
bit Task_1ms_Flag = 0;
bit Task_10ms_Flag = 0;
bit Task_100ms_Flag = 0;
bit Task_1s_Flag = 0;

// 时间计数
static u16 cnt_10ms = 0;
static u16 cnt_100ms = 0;
static u16 cnt_1s = 0;

/*******************************************************************************
 * 函数名称: Timer0_ISR
 * 函数功能: Timer0 中断（1ms 时基）
 ******************************************************************************/
void Timer0_ISR(void) interrupt TMR0_VECTOR
{
    Task_1ms_Flag = 1;  // 1ms 任务标志
    
    // 生成其他时基
    if(++cnt_10ms >= 10)
    {
        cnt_10ms = 0;
        Task_10ms_Flag = 1;
    }
    
    if(++cnt_100ms >= 100)
    {
        cnt_100ms = 0;
        Task_100ms_Flag = 1;
    }
    
    if(++cnt_1s >= 1000)
    {
        cnt_1s = 0;
        Task_1s_Flag = 1;
    }
}

/*******************************************************************************
 * 函数名称: Task_Handler
 * 函数功能: 任务调度器
 ******************************************************************************/
void Task_Handler(void)
{
    if(Task_1ms_Flag)
    {
        Task_1ms_Flag = 0;
        Task_1ms();
    }
    
    if(Task_10ms_Flag)
    {
        Task_10ms_Flag = 0;
        Task_10ms();
    }
    
    if(Task_100ms_Flag)
    {
        Task_100ms_Flag = 0;
        Task_100ms();
    }
    
    if(Task_1s_Flag)
    {
        Task_1s_Flag = 0;
        Task_1s();
    }
}

/*******************************************************************************
 * 各任务实现
 ******************************************************************************/

// 1ms 任务 - 高优先级，快速响应
void Task_1ms(void)
{
    // 按键扫描
    Key_Scan();
}

// 10ms 任务 - 常规任务
void Task_10ms(void)
{
    // ADC 采样
    ADC_Sample();
}

// 100ms 任务 - 较慢任务
void Task_100ms(void)
{
    // LED 闪烁
    LED_Toggle();
}

// 1s 任务 - 低频任务
void Task_1s(void)
{
    // 打印状态
    printf("System OK\r\n");
}
```

---

## 📋 模板 4：状态机模板

适合：有多个工作状态的项目

### main.c

```c
#include "config.h"
#include "system.h"

// 状态定义
typedef enum
{
    STATE_INIT = 0,     // 初始化状态
    STATE_IDLE,         // 空闲状态
    STATE_WORKING,      // 工作状态
    STATE_ERROR,        // 错误状态
    STATE_SLEEP         // 睡眠状态
} SystemState_t;

// 全局变量
SystemState_t current_state = STATE_INIT;
SystemState_t next_state = STATE_INIT;

// 状态处理函数
void State_Init_Handler(void);
void State_Idle_Handler(void);
void State_Working_Handler(void);
void State_Error_Handler(void);
void State_Sleep_Handler(void);

void main(void)
{
    System_Init();
    
    while(1)
    {
        // 状态机调度
        switch(current_state)
        {
            case STATE_INIT:
                State_Init_Handler();
                break;
                
            case STATE_IDLE:
                State_Idle_Handler();
                break;
                
            case STATE_WORKING:
                State_Working_Handler();
                break;
                
            case STATE_ERROR:
                State_Error_Handler();
                break;
                
            case STATE_SLEEP:
                State_Sleep_Handler();
                break;
                
            default:
                current_state = STATE_INIT;
                break;
        }
        
        // 状态切换
        if(next_state != current_state)
        {
            printf("State Change: %d -> %d\r\n", current_state, next_state);
            current_state = next_state;
        }
    }
}

// 初始化状态
void State_Init_Handler(void)
{
    printf("State: INIT\r\n");
    
    // 执行初始化
    // ...
    
    // 切换到空闲状态
    next_state = STATE_IDLE;
}

// 空闲状态
void State_Idle_Handler(void)
{
    // 等待事件
    if(Key_Pressed())
    {
        next_state = STATE_WORKING;
    }
}

// 工作状态
void State_Working_Handler(void)
{
    // 执行工作
    printf("Working...\r\n");
    
    // 工作完成
    if(Work_Done())
    {
        next_state = STATE_IDLE;
    }
}

// 错误状态
void State_Error_Handler(void)
{
    printf("Error!\r\n");
    LED_Error_Blink();
    
    // 恢复
    if(Error_Recovered())
    {
        next_state = STATE_IDLE;
    }
}

// 睡眠状态
void State_Sleep_Handler(void)
{
    printf("Sleep...\r\n");
    PCON |= 0x01;  // 进入 Idle 模式
    
    // 唤醒后
    next_state = STATE_IDLE;
}
```

---

## 📋 模板 5：完整项目框架

适合：大型项目，团队开发

### 目录结构

```
MyProject/
│
├── Doc/                    # 文档
│   ├── README.md
│   ├── 设计文档.md
│   └── API 文档.md
│
├── Hardware/               # 硬件层
│   ├── inc/
│   │   ├── led.h
│   │   ├── key.h
│   │   ├── lcd.h
│   │   └── sensor.h
│   └── src/
│       ├── led.c
│       ├── key.c
│       ├── lcd.c
│       └── sensor.c
│
├── Driver/                 # 驱动层（AI8051U 库文件）
│   ├── AI8051U_*.c/h
│   └── ...
│
├── App/                    # 应用层
│   ├── inc/
│   │   ├── app.h
│   │   ├── protocol.h
│   │   └── algorithm.h
│   └── src/
│       ├── app.c
│       ├── protocol.c
│       └── algorithm.c
│
├── User/                   # 用户层
│   ├── main.c
│   ├── config.h
│   ├── system.c/h
│   └── task.c/h
│
├── Project/                # 工程文件
│   └── MyProject.uvproj
│
└── Output/                 # 输出文件
    ├── *.hex
    └── *.map
```

---

## 🔧 Keil 工程配置

### 1. Target 设置

```
Target → Target Options
├── Device: AI8051U（选择对应型号）
├── Xtal (MHz): 40.0（根据实际主频）
└── Memory Model: Large
```

### 2. Output 设置

```
Output → Output Options
├── ✓ Create HEX File
├── Name of Executable: MyProject
└── Select Folder for Objects: ./Objects/
```

### 3. C51 编译选项

```
C51 → C51 Options
├── Optimization Level: 9（最高优化）
├── ✓ Browse Information
└── Define: 根据需要定义宏
```

### 4. BL51 链接选项

```
BL51 → BL51 Options
├── XDATA: 0x0000-0x3FFF（根据实际）
├── CODE: 0x0000-0x7FFF（根据实际）
└── ✓ Use Memory Layout from Target Dialog
```

---

## 📝 代码规范建议

### 文件头注释

```c
/*******************************************************************************
 * 文件名称: filename.c
 * 项目名称: ProjectName
 * 创建日期: 2025-XX-XX
 * 作    者: Your Name
 * 版    本: V1.0
 * 功能描述: 简要描述文件功能
 * 修改记录:
 *   2025-XX-XX V1.0 初始版本
 ******************************************************************************/
```

### 函数注释

```c
/*******************************************************************************
 * 函数名称: Function_Name
 * 函数功能: 简要描述函数功能
 * 输入参数: param1 - 参数 1 说明
 *          param2 - 参数 2 说明
 * 返 回 值: 返回值说明
 * 说    明: 其他说明（可选）
 ******************************************************************************/
```

### 命名规范

```c
// 宏定义 - 全大写，下划线分隔
#define MAX_BUFFER_SIZE  128
#define LED_PIN          P00

// 变量 - 小写，下划线分隔
u8 buffer_count;
u16 adc_value;

// 函数 - 首字母大写，下划线分隔
void System_Init(void);
u8 Get_ADC_Value(u8 channel);

// 类型定义 - 首字母大写，_t 结尾
typedef struct
{
    u8 data;
    u8 length;
} Buffer_t;
```

---

## 🚀 快速开始步骤

### 步骤 1：复制模板

从 `库文件/` 目录复制需要的文件到你的项目目录。

### 步骤 2：创建 Keil 工程

1. 打开 Keil，新建工程
2. 选择 AI8051U 芯片
3. 添加源文件到工程
4. 配置工程选项

### 步骤 3：修改配置

在 `config.h` 中配置主频、外设等：

```c
#define MAIN_Fosc  40000000L  // 主频
```

### 步骤 4：编写代码

在 `main.c` 中编写你的应用代码。

### 步骤 5：编译下载

1. 按 `F7` 编译
2. 使用 STC-ISP 下载
3. 测试运行

---

## 💡 提示

1. **从简单开始** - 先用最小系统模板验证基本功能
2. **逐步添加** - 需要什么功能就添加对应的驱动文件
3. **参考示例** - 参考 `独立程序/` 中的例子
4. **保持整洁** - 及时删除不需要的代码和文件
5. **版本控制** - 使用 Git 管理你的项目

---

## 📚 相关文档

- [AI8051U-使用文档.md](./AI8051U-使用文档.md) - 详细教程
- [AI8051U-快速参考.md](./AI8051U-快速参考.md) - 快速查询
- [README.md](./README.md) - 项目总览

---

## 🎯 下一步

选择合适的模板，开始你的 AI8051U 项目吧！

**祝开发顺利！** 🚀

