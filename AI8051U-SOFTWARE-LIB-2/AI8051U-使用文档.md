# AI8051U 软件库详细使用文档

> **版本**: V2.0  
> **更新日期**: 2025-04-10  
> **官方网站**: www.STCAI.com  
> **适用芯片**: AI8051U 系列 32 位增强型 8051 单片机

---

## 目录

1. [快速入门](#1-快速入门)
2. [开发环境搭建](#2-开发环境搭建)
3. [项目结构说明](#3-项目结构说明)
4. [系统配置](#4-系统配置)
5. [GPIO 模块使用](#5-gpio-模块使用)
6. [定时器模块](#6-定时器模块)
7. [串口通信 (UART)](#7-串口通信-uart)
8. [ADC 模块](#8-adc-模块)
9. [PWM 模块](#9-pwm-模块)
10. [SPI 通信](#10-spi-通信)
11. [I2C 通信](#11-i2c-通信)
12. [DMA 模块](#12-dma-模块)
13. [USB 功能](#13-usb-功能)
14. [其他外设](#14-其他外设)
15. [常见问题](#15-常见问题)
16. [API 参考](#16-api-参考)

---

## 1. 快速入门

### 1.1 五分钟点亮第一个 LED

**第一步：打开示例工程**
```
独立程序/01-IO-跑马灯/IO-LED.uvproj
```

**第二步：理解代码结构**
```c
#include "config.h"
#include "AI8051U_GPIO.h"
#include "AI8051U_Delay.h"

void main(void)
{
    WTST = 0;        // 设置程序指令延时参数
    EAXSFR();        // 扩展 SFR 访问使能
    CKCON = 0;       // 提高访问 XRAM 速度
    
    GPIO_config();   // GPIO 初始化
    P40 = 0;         // 点亮 LED 电源
    
    while(1)
    {
        delay_ms(250);
        P0 = ~ledNum[ledIndex];    // 跑马灯效果
        ledIndex++;
        if(ledIndex > 7) ledIndex = 0;
    }
}
```

**第三步：编译下载**
1. 按 `F7` 编译
2. 使用 STC-ISP 工具下载到开发板
3. 观察 LED 跑马灯效果

### 1.2 三个重要初始化

所有程序的 `main()` 函数开头都必须包含：

```c
WTST = 0;        // CPU 执行指令速度最快
EAXSFR();        // 使能扩展寄存器访问
CKCON = 0;       // XRAM 高速访问
SET_TPS();       // 设置系统等待时间单位（用于 EEPROM/SPI/I2C）
```

---

## 2. 开发环境搭建

### 2.1 必需工具

| 工具 | 版本要求 | 用途 | 下载地址 |
|------|---------|------|---------|
| Keil C51 | V9.0+ | 代码编译 | www.keil.com |
| STC-ISP | 最新版 | 程序下载 | www.stcai.com |
| 串口调试助手 | 任意 | 串口调试 | - |

### 2.2 Keil 配置

**安装中断向量扩展插件：**
```
软件工具/拓展Keil的C代码中断号.exe
```
运行后可支持 70+ 个中断向量。

**项目设置：**
- Target: 选择对应的 AI8051U 型号
- Output: 勾选 "Create HEX File"
- C51: Optimization Level 选择 9 或 8
- BL51: 根据实际内存大小设置 XDATA/CODE

### 2.3 硬件连接

**最小系统：**
```
VCC  ────┐
         ├─ AI8051U
GND  ────┘
         
UART1_TX (P3.1) ──► USB-TTL 串口
UART1_RX (P3.0) ◄── USB-TTL 串口
```

---

## 3. 项目结构说明

### 3.1 库文件目录结构

```
库文件/
├── AI8051U.H              # 芯片寄存器定义（核心文件）
├── config.h               # 系统配置文件
├── def.h                  # 类型定义
├── Type_def.h             # 自定义类型
│
├── AI8051U_GPIO.c/h       # GPIO 驱动
├── AI8051U_UART.c/h       # 串口驱动
├── AI8051U_Timer.c/h      # 定时器驱动
├── AI8051U_ADC.c/h        # ADC 驱动
├── AI8051U_PWM.c/h        # PWM 驱动
├── AI8051U_SPI.c/h        # SPI 驱动
├── AI8051U_I2C.c/h        # I2C 驱动
├── AI8051U_DMA.c/h        # DMA 驱动
├── AI8051U_EEPROM.c/h     # EEPROM 驱动
├── AI8051U_RTC.c/h        # RTC 驱动
├── AI8051U_WDT.c/h        # 看门狗驱动
├── AI8051U_Compare.c/h    # 比较器驱动
├── AI8051U_QSPI.c/h       # QSPI 驱动
├── AI8051U_LCM.c/h        # LCM 接口驱动
│
├── *_Isr.c                # 各模块中断服务程序
├── isr.asm                # 中断向量汇编
│
└── *.LIB                  # 预编译库文件
```

### 3.2 独立程序结构

每个示例都是独立的 Keil 工程：
```
01-IO-跑马灯/
├── main.c                 # 主程序
├── AI8051U_GPIO.c/h       # 需要的驱动文件
├── AI8051U.H              # 寄存器定义
├── config.h               # 配置文件
├── IO-LED.uvproj          # Keil 工程
└── list/                  # 编译输出
    └── *.hex              # 十六进制文件
```

### 3.3 综合程序结构（推荐架构）

```
综合程序/
├── Driver/                # 驱动层（HAL）
│   └── 所有库文件
│
├── App/                   # 应用层
│   ├── inc/              # 应用头文件
│   │   ├── app.h         # 应用总头文件
│   │   ├── APP_*.h       # 各功能模块头文件
│   │   └── font.h        # 字体资源
│   └── src/              # 应用源文件
│       ├── APP.c         # 应用主文件
│       └── APP_*.c       # 各功能模块实现
│
├── User/                  # 用户层
│   ├── main.c            # 主程序入口
│   ├── Task.c/h          # 任务调度
│   └── System_init.c/h   # 系统初始化
│
└── RVMDK/                 # Keil 工程
    └── *.uvproj
```

---

## 4. 系统配置

### 4.1 config.h 配置详解

```c
// ========== 时钟配置 ==========
#define MAIN_Fosc    40000000L    // 主时钟频率（Hz）
// 可选值：40MHz, 24MHz, 22.1184MHz, 12MHz, 11.0592MHz, 5.5296MHz

// ========== 系统时间单位 ==========
#define SET_TPS()    IAP_TPS = (MAIN_Fosc / 1000000L)
// 用于 EEPROM、SPI、I2C 操作的时间计算

// ========== IRC 时钟去抖 ==========
#define IRC_Debounce(n)    IRCDB = n
// 初始值：0x80，频率越高数值越小（最小 0x10）
```

### 4.2 时钟源选择

AI8051U 支持多种时钟源：

| 时钟源 | 频率范围 | 精度 | 用途 |
|--------|---------|------|------|
| 内部 IRC | 5MHz~40MHz | ±1% | 通用 |
| 外部晶振 | 4MHz~40MHz | ±50ppm | 高精度串口 |
| IRC 32KHz | 32.768KHz | ±10% | 低功耗 RTC |
| 外部 32K | 32.768KHz | ±20ppm | 高精度 RTC |
| USB 48MHz | 48MHz | USB 同步 | USB 应用 |

**时钟切换代码：**
```c
// 使能 IRC 并等待稳定
HIRCCR = 0x80;
while (!(HIRCCR & 0x01));  // 等待就绪

// 选择时钟源
CLKSEL = 0x00;  // IRC
// CLKSEL = 0x01;  // 外部晶振
// CLKSEL = 0x03;  // 内部 32K

// 时钟分频（可选）
CLKDIV = 0x00;  // 不分频
// CLKDIV = 0x01;  // 2 分频
```

### 4.3 电源模式

```c
// 正常模式
// 默认状态，全速运行

// 空闲模式（Idle）
PCON |= 0x01;  // 进入 Idle，任意中断唤醒

// 掉电模式（Power Down）
PCON |= 0x02;  // 进入 PD，仅外部中断/RTC 唤醒
```

---

## 5. GPIO 模块使用

### 5.1 GPIO 四种工作模式

| 模式 | 说明 | 上拉 | 适用场景 |
|------|------|------|---------|
| 准双向口 | 弱上拉，可输入输出 | 有 | 通用 I/O |
| 高阻输入 | 纯输入，无上拉 | 无 | ADC 输入、低功耗 |
| 开漏输出 | 需外部上拉 | 无 | I2C、总线 |
| 推挽输出 | 强驱动输出 | 无 | LED、继电器 |

### 5.2 GPIO 快速配置（宏定义）

```c
#include "AI8051U_GPIO.h"

// ===== 模式配置 =====
P0_MODE_IO_PU(GPIO_Pin_All);     // P0 全部配置为准双向口
P1_MODE_IN_HIZ(GPIO_Pin_0);      // P1.0 配置为高阻输入
P2_MODE_OUT_OD(GPIO_Pin_1);      // P2.1 配置为开漏输出
P3_MODE_OUT_PP(GPIO_Pin_2);      // P3.2 配置为推挽输出

// ===== 上拉/下拉配置 =====
P0_PULL_UP_ENABLE(GPIO_Pin_0);   // P0.0 使能内部上拉
P0_PULL_DOWN_ENABLE(GPIO_Pin_1); // P0.1 使能内部下拉

// ===== 速度配置 =====
P0_SPEED_HIGH(GPIO_Pin_All);     // P0 高速模式（大电流）
P1_SPEED_LOW(GPIO_Pin_All);      // P1 低速模式（低 EMI）

// ===== 施密特触发器 =====
P0_ST_ENABLE(GPIO_Pin_All);      // 使能施密特触发（抗干扰）

// ===== 数字输入使能 =====
P0_DIGIT_IN_ENABLE(GPIO_Pin_All); // 使能数字输入缓冲
```

### 5.3 GPIO 结构体配置

```c
void GPIO_Example(void)
{
    GPIO_InitTypeDef gpio;
    
    // 配置 P0.0~P0.7 为推挽输出
    gpio.Mode = GPIO_OUT_PP;
    gpio.Pin = GPIO_Pin_All;
    GPIO_Inilize(GPIO_P0, &gpio);
    
    // 配置 P1.0 为高阻输入
    gpio.Mode = GPIO_HighZ;
    gpio.Pin = GPIO_Pin_0;
    GPIO_Inilize(GPIO_P1, &gpio);
}
```

### 5.4 GPIO 中断配置

```c
void GPIO_Interrupt_Example(void)
{
    GPIO_Int_InitTypeDef gpio_int;
    
    // 配置 P3.2 (INT0) 下降沿中断
    gpio_int.Mode = GPIO_FALLING_EDGE;  // 下降沿触发
    gpio_int.Pin = GPIO_Pin_2;
    gpio_int.IntEnable = ENABLE;
    gpio_int.Priority = Priority_1;      // 优先级 1
    gpio_int.WakeUpEn = ENABLE;         // 允许唤醒
    
    GPIO_INT_Inilize(GPIO_P3, &gpio_int);
    
    EA = 1;  // 使能总中断
}

// 中断服务程序
void EXTI0_ISR(void) interrupt INT0_VECTOR
{
    // 处理中断
}
```

### 5.5 GPIO 实用示例

**示例 1：按键检测（带消抖）**
```c
#define KEY_PIN  P32

u8 Key_Scan(void)
{
    static u8 key_state = 0;
    
    if (KEY_PIN == 0)  // 按键按下
    {
        delay_ms(10);  // 消抖
        if (KEY_PIN == 0 && key_state == 0)
        {
            key_state = 1;
            return 1;  // 按键按下
        }
    }
    else
    {
        key_state = 0;
    }
    return 0;
}
```

**示例 2：LED 闪烁**
```c
void LED_Blink(void)
{
    P0_MODE_OUT_PP(GPIO_Pin_0);
    
    while(1)
    {
        P00 = 0;        // LED 亮
        delay_ms(500);
        P00 = 1;        // LED 灭
        delay_ms(500);
    }
}
```

---

## 6. 定时器模块

### 6.1 定时器资源

AI8051U 提供 **6 个定时器**：

| 定时器 | 位数 | 最大计数 | 特殊功能 |
|--------|------|---------|---------|
| Timer0 | 16 | 65536 | 可作 UART1 波特率发生器 |
| Timer1 | 16 | 65536 | 可作 UART1 波特率发生器 |
| Timer2 | 16 | 65536 | 可作 UART1/2/3/4 波特率发生器 |
| Timer3 | 16 | 65536 | 可作 UART3 波特率发生器 |
| Timer4 | 16 | 65536 | 可作 UART4 波特率发生器 |
| Timer11 | 16 | 65536 | 专用定时器 |

### 6.2 定时器配置

```c
#include "AI8051U_Timer.h"

void Timer0_Config(void)
{
    TIM_InitTypeDef tim;
    
    tim.TIM_Mode = TIM_16BitAutoReload;     // 16 位自动重载
    tim.TIM_ClkSource = TIM_CLOCK_1T;       // 1T 模式（最快）
    tim.TIM_ClkOut = DISABLE;               // 不输出时钟
    tim.TIM_Value = 65536 - (MAIN_Fosc / 1000);  // 1ms 定时
    tim.TIM_Run = ENABLE;                   // 启动定时器
    
    Timer_Inilize(TIM_Timer0, &tim);
    
    // 中断配置
    NVIC_Timer0_Init(ENABLE, Priority_1);
    EA = 1;
}

// 中断服务程序
void TM0_ISR(void) interrupt TMR0_VECTOR
{
    static u16 cnt = 0;
    
    if (++cnt >= 1000)  // 1 秒
    {
        cnt = 0;
        // 执行 1 秒任务
    }
}
```

### 6.3 定时时间计算

**公式：**
```
定时时间 = (65536 - TIM_Value) / (主频 / 分频系数)
```

**示例：**
```c
// 40MHz 主频，1T 模式，定时 1ms
TIM_Value = 65536 - (40000000 / 1000) = 25536

// 24MHz 主频，12T 模式，定时 10ms
TIM_Value = 65536 - (24000000 / 12 / 100) = 45536
```

### 6.4 PWM 输出（使用定时器）

```c
// 使用 Timer0 产生 PWM（P3.4）
void Timer0_PWM_Init(void)
{
    P3_MODE_OUT_PP(GPIO_Pin_4);
    
    TIM_InitTypeDef tim;
    tim.TIM_Mode = TIM_16BitAutoReload;
    tim.TIM_ClkSource = TIM_CLOCK_1T;
    tim.TIM_ClkOut = ENABLE;        // 使能时钟输出
    tim.TIM_Value = 65536 - 100;    // PWM 频率
    tim.TIM_Run = ENABLE;
    
    Timer_Inilize(TIM_Timer0, &tim);
}
```

---

## 7. 串口通信 (UART)

### 7.1 UART 资源

| 串口 | 引脚（默认） | 波特率发生器 | DMA 支持 |
|------|------------|------------|---------|
| UART1 | P3.0(RX), P3.1(TX) | Timer1/2 | 是 |
| UART2 | P1.0(RX), P1.1(TX) | Timer2 | 是 |
| UART3 | P0.0(RX), P0.1(TX) | Timer2/3 | 是 |
| UART4 | P0.2(RX), P0.3(TX) | Timer2/4 | 是 |

### 7.2 UART 基础配置

```c
#include "AI8051U_UART.h"

void UART1_Config(void)
{
    COMx_InitDefine com;
    
    com.UART_Mode = UART_8bit_BRTx;          // 8 位数据，可变波特率
    com.UART_BRT_Use = BRT_Timer1;           // 使用 Timer1 作波特率发生器
    com.UART_BaudRate = 115200;              // 波特率 115200
    com.UART_RxEnable = ENABLE;              // 使能接收
    com.BaudRateDouble = DISABLE;            // 波特率不加倍
    com.ParityMode = PARITY_NONE;            // 无校验
    
    // 超时配置（可选）
    com.TimeOutEnable = ENABLE;              // 使能接收超时
    com.TimeOutINTEnable = ENABLE;           // 使能超时中断
    com.TimeOutScale = TO_SCALE_SYSCLK;      // 超时时钟源
    com.TimeOutTimer = (MAIN_Fosc / 1000);   // 1ms 超时
    
    UART_Configuration(UART1, &com);
    
    // 中断配置
    NVIC_UART1_Init(ENABLE, Priority_1);
    EA = 1;
}
```

### 7.3 UART 数据收发

**方式 1：中断模式（推荐）**
```c
// 发送单字节
TX1_write2buff(0x55);

// 发送字符串
PrintString1("Hello World!\r\n");

// 在中断中处理接收数据
void UART1_ISR(void) interrupt UART1_VECTOR
{
    if (RI)
    {
        CLR_RI();
        u8 dat = SBUF;
        // 处理接收到的数据
        RX1_Buffer[COM1.RX_Cnt++] = dat;
    }
    
    if (TI)
    {
        CLR_TI();
        // 发送下一个字节
        if (COM1.TX_send != COM1.TX_write)
        {
            SBUF = TX1_Buffer[COM1.TX_send];
            COM1.TX_send = (COM1.TX_send + 1) % COM_TX1_Lenth;
        }
        else
        {
            COM1.B_TX_busy = 0;
        }
    }
}
```

**方式 2：查询模式**
```c
// 发送
void UART1_Send_Byte(u8 dat)
{
    SBUF = dat;
    while(!TI);  // 等待发送完成
    CLR_TI();
}

// 接收
u8 UART1_Recv_Byte(void)
{
    while(!RI);  // 等待接收
    CLR_RI();
    return SBUF;
}
```

### 7.4 Printf 重定向

```c
// 在 AI8051U_UART.h 中配置
#define PRINTF_SELECT  UART1  // 选择 printf 使用的串口

// 使用 printf
printf("Temperature: %d.%d C\r\n", temp/10, temp%10);
printf("ADC Value: 0x%04X\r\n", adc_val);
```

### 7.5 多串口应用示例

```c
// 4 个串口同时工作
void Multi_UART_Example(void)
{
    UART1_Config();  // 配置 UART1
    UART2_Config();  // 配置 UART2
    UART3_Config();  // 配置 UART3
    UART4_Config();  // 配置 UART4
    
    while(1)
    {
        // UART1 发送数据
        PrintString1("UART1 Data\r\n");
        
        // UART2 发送数据
        PrintString2("UART2 Data\r\n");
        
        // 检查接收
        if (COM1.RX_Cnt > 0)
        {
            // 处理 UART1 接收数据
        }
        
        delay_ms(1000);
    }
}
```

---

## 8. ADC 模块

### 8.1 ADC 特性

- **分辨率**: 12 位（4096 级）
- **通道数**: 15 个外部通道 + 内部 BandGap
- **转换时间**: 可配置（90~540 个时钟周期）
- **参考电压**: VCC 或内部 1.19V
- **DMA 支持**: 是

### 8.2 ADC 基础配置

```c
#include "AI8051U_ADC.h"

void ADC_Config(void)
{
    ADC_InitTypeDef adc;
    
    adc.ADC_Channels = ADC_CH0 | ADC_CH1;    // 使用 CH0 和 CH1
    adc.ADC_Speed = ADC_SPEED_2X16T;         // 转换速度 32T
    adc.ADC_Power = ENABLE;                  // ADC 上电
    adc.ADC_AdjResult = ADC_RIGHT_JUSTIFIED; // 右对齐
    adc.ADC_Polity = Priority_0;             // 中断优先级
    adc.ADC_Interrupt = DISABLE;             // 不使用中断
    
    ADC_Inilize(&adc);
    
    // GPIO 配置（ADC 输入必须配置为高阻）
    P1_MODE_IN_HIZ(GPIO_Pin_0 | GPIO_Pin_1);
}
```

### 8.3 ADC 转换

**单次转换：**
```c
u16 Get_ADC_Value(u8 channel)
{
    ADC_CONTR = (ADC_CONTR & 0xF0) | channel;  // 选择通道
    ADC_START = 1;                              // 启动转换
    
    _nop_();
    _nop_();
    _nop_();
    _nop_();
    
    while(ADC_FLAG == 0);  // 等待转换完成
    ADC_FLAG = 0;          // 清除标志
    
    return (ADC_RES << 8) | ADC_RESL;  // 读取结果
}
```

**连续采样：**
```c
void ADC_Multi_Sample(void)
{
    u16 adc_buf[8];
    u8 i;
    
    for(i=0; i<8; i++)
    {
        adc_buf[i] = Get_ADC_Value(ADC_CH0);
        delay_ms(10);
    }
    
    // 计算平均值
    u32 sum = 0;
    for(i=0; i<8; i++)
        sum += adc_buf[i];
    
    u16 average = sum / 8;
    printf("ADC Average: %d\r\n", average);
}
```

### 8.4 内部 BandGap 电压测量

```c
// 测量内部 1.19V 基准，用于计算实际 VCC
u16 Get_BandGap_Voltage(void)
{
    u16 adc_val;
    
    // 使能 BandGap
    ADCCFG |= 0x80;  // 使能 BandGap
    delay_ms(5);     // 等待稳定
    
    adc_val = Get_ADC_Value(ADC_CH15);  // CH15 是 BandGap
    
    // 计算 VCC（单位：mV）
    // VCC = 1190 * 4096 / adc_val
    u32 vcc = 4874240UL / adc_val;
    
    return (u16)vcc;
}
```

### 8.5 温度传感器示例

```c
// 使用 NTC 热敏电阻测温
u16 Get_Temperature(void)
{
    u16 adc_val = Get_ADC_Value(ADC_CH0);
    
    // 根据 NTC 特性转换为温度
    // 这里需要根据实际 NTC 参数计算
    // 简化示例：
    float voltage = (float)adc_val * 5.0 / 4096.0;
    float temp = (voltage - 0.5) * 100.0;  // LM35 示例
    
    return (u16)(temp * 10);  // 返回温度 x10
}
```

---

## 9. PWM 模块

### 9.1 PWM 资源

AI8051U 提供 **8 路高级 PWM**：

| PWM 组 | 通道 | 引脚（默认） | 特性 |
|--------|------|------------|------|
| PWMA | PWM1~4 | P2.0~P2.3 | 死区控制、刹车、互补输出 |
| PWMB | PWM5~8 | P2.4~P2.7 | 死区控制、刹车、互补输出 |

### 9.2 PWM 基础配置

```c
#include "AI8051U_PWM.h"

void PWM_Config(void)
{
    PWMx_InitDefine pwm;
    
    pwm.PWM_Mode = CCMRn_PWM_MODE1;          // PWM 模式 1
    pwm.PWM_Duty = 1000;                     // 占空比计数值
    pwm.PWM_EnoSelect = ENO_PWM1P_PWM1N;     // 使能 PWM1P/PWM1N
    pwm.PWM_CEN_Enable = ENABLE;             // 使能计数器
    pwm.PWM_CCRP_Enable = DISABLE;           // 不使用比较器
    pwm.PWM_CCMR_Enable = ENABLE;            // 使能比较模式
    pwm.PWM_CCRn_Polity = CCR_POL_HIGH;      // 高电平有效
    pwm.PWM_Period = 2000;                   // PWM 周期
    pwm.PWM_DeadTime = 0;                    // 死区时间
    pwm.PWM_MainOutEnable = ENABLE;          // 使能主输出
    pwm.PWM_CEN_Enable = ENABLE;             // 启动 PWM
    
    PWMx_Configuration(PWM1, &pwm);
    
    // GPIO 配置
    P2_MODE_OUT_PP(GPIO_Pin_0 | GPIO_Pin_1);
}
```

### 9.3 PWM 占空比调节

```c
// 设置 PWM 占空比（0-100%）
void PWM_Set_Duty(u8 duty_percent)
{
    u16 duty;
    
    duty = (u32)pwm.PWM_Period * duty_percent / 100;
    
    // 更新占空比
    PWMA_CCR1H = (u8)(duty >> 8);
    PWMA_CCR1L = (u8)duty;
}

// 示例：呼吸灯
void Breathing_LED(void)
{
    u8 i;
    
    while(1)
    {
        // 渐亮
        for(i=0; i<=100; i++)
        {
            PWM_Set_Duty(i);
            delay_ms(10);
        }
        
        // 渐灭
        for(i=100; i>0; i--)
        {
            PWM_Set_Duty(i);
            delay_ms(10);
        }
    }
}
```

### 9.4 PWM 频率计算

**公式：**
```
PWM频率 = 主频 / (预分频 * PWM_Period)
```

**示例：**
```c
// 40MHz 主频，不分频，10kHz PWM
PWM_Period = 40000000 / 10000 = 4000

// 24MHz 主频，2 分频，1kHz PWM
PWM_Period = 24000000 / 2 / 1000 = 12000
```

### 9.5 互补 PWM 输出（电机驱动）

```c
void Motor_PWM_Config(void)
{
    PWMx_InitDefine pwm;
    
    pwm.PWM_Mode = CCMRn_PWM_MODE1;
    pwm.PWM_Duty = 1500;
    pwm.PWM_EnoSelect = ENO_PWM1P_PWM1N;     // 互补输出
    pwm.PWM_Period = 2000;
    pwm.PWM_DeadTime = 50;                    // 50 个时钟死区
    pwm.PWM_MainOutEnable = ENABLE;
    pwm.PWM_CEN_Enable = ENABLE;
    
    PWMx_Configuration(PWM1, &pwm);
    
    // 配置 GPIO 为推挽输出
    P2_MODE_OUT_PP(GPIO_Pin_0 | GPIO_Pin_1);
}
```

---

## 10. SPI 通信

### 10.1 SPI 特性

- **模式**: 主机/从机
- **速度**: 最高 Fsys/2
- **模式**: Mode 0-3
- **DMA 支持**: 是
- **高速 SPI**: 支持 HSSPI 模式

### 10.2 SPI 主机配置

```c
#include "AI8051U_SPI.h"

void SPI_Master_Init(void)
{
    SPI_InitTypeDef spi;
    
    spi.SPI_Module = SPI_Module_SPI;         // 使用 SPI 模块
    spi.SPI_SSIG = ENABLE;                   // SS 不自动控制
    spi.SPI_FirstBit = SPI_MSB;              // 高位先行
    spi.SPI_Mode = SPI_Mode_Master;          // 主机模式
    spi.SPI_CPOL = SPI_CPOL_Low;             // 时钟极性
    spi.SPI_CPHA = SPI_CPHA_1Edge;           // 时钟相位
    spi.SPI_Speed = SPI_Speed_4;             // 4 分频
    spi.SPI_Enable = ENABLE;                 // 使能 SPI
    spi.SPI_Interrupt = DISABLE;             // 不使用中断
    
    SPI_Inilize(&spi);
    
    // GPIO 配置
    P1_MODE_OUT_PP(GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4);  // MOSI, SCLK, SS
    P1_MODE_IN_HIZ(GPIO_Pin_5);                            // MISO
}
```

### 10.3 SPI 数据传输

```c
// 发送并接收一个字节
u8 SPI_Transfer(u8 dat)
{
    SPDAT = dat;           // 写入数据
    while(SPIF == 0);      // 等待传输完成
    SPIF = 0;              // 清除标志
    return SPDAT;          // 返回接收数据
}

// 连续传输
void SPI_Transfer_Buffer(u8 *tx_buf, u8 *rx_buf, u16 len)
{
    u16 i;
    
    for(i=0; i<len; i++)
    {
        rx_buf[i] = SPI_Transfer(tx_buf[i]);
    }
}
```

### 10.4 W25Q64 Flash 操作示例

```c
#define SPI_CS  P14

void W25Q64_Init(void)
{
    SPI_Master_Init();
    SPI_CS = 1;  // CS 高电平
}

// 读取设备 ID
u16 W25Q64_Read_ID(void)
{
    u16 id;
    
    SPI_CS = 0;
    SPI_Transfer(0x90);  // 读 ID 命令
    SPI_Transfer(0x00);
    SPI_Transfer(0x00);
    SPI_Transfer(0x00);
    id = SPI_Transfer(0xFF) << 8;
    id |= SPI_Transfer(0xFF);
    SPI_CS = 1;
    
    return id;  // 应返回 0xEF16
}

// 读取数据
void W25Q64_Read_Data(u32 addr, u8 *buf, u16 len)
{
    u16 i;
    
    SPI_CS = 0;
    SPI_Transfer(0x03);               // 读命令
    SPI_Transfer((u8)(addr >> 16));
    SPI_Transfer((u8)(addr >> 8));
    SPI_Transfer((u8)addr);
    
    for(i=0; i<len; i++)
        buf[i] = SPI_Transfer(0xFF);
    
    SPI_CS = 1;
}

// 写使能
void W25Q64_Write_Enable(void)
{
    SPI_CS = 0;
    SPI_Transfer(0x06);
    SPI_CS = 1;
}

// 扇区擦除
void W25Q64_Erase_Sector(u32 addr)
{
    W25Q64_Write_Enable();
    
    SPI_CS = 0;
    SPI_Transfer(0x20);               // 扇区擦除命令
    SPI_Transfer((u8)(addr >> 16));
    SPI_Transfer((u8)(addr >> 8));
    SPI_Transfer((u8)addr);
    SPI_CS = 1;
    
    delay_ms(500);  // 等待擦除完成
}

// 页编程
void W25Q64_Write_Page(u32 addr, u8 *buf, u16 len)
{
    u16 i;
    
    W25Q64_Write_Enable();
    
    SPI_CS = 0;
    SPI_Transfer(0x02);               // 页编程命令
    SPI_Transfer((u8)(addr >> 16));
    SPI_Transfer((u8)(addr >> 8));
    SPI_Transfer((u8)addr);
    
    for(i=0; i<len; i++)
        SPI_Transfer(buf[i]);
    
    SPI_CS = 1;
    
    delay_ms(5);  // 等待编程完成
}
```

---

## 11. I2C 通信

### 11.1 I2C 特性

- **模式**: 主机/从机
- **速度**: 标准模式（100kHz）/ 快速模式（400kHz）
- **7位/10位地址**: 都支持
- **DMA 支持**: 是

### 11.2 I2C 主机配置

```c
#include "AI8051U_I2C.h"

void I2C_Master_Init(void)
{
    I2C_InitTypeDef i2c;
    
    i2c.I2C_Mode = I2C_Mode_Master;          // 主机模式
    i2c.I2C_Enable = ENABLE;                 // 使能 I2C
    i2c.I2C_MS_WDTA = DISABLE;               // 不使用 WDTA
    i2c.I2C_Speed = 400000;                  // 400kHz
    
    I2C_Init(&i2c);
    
    // GPIO 配置（开漏输出 + 上拉）
    P1_MODE_OUT_OD(GPIO_Pin_6 | GPIO_Pin_7);
    P1_PULL_UP_ENABLE(GPIO_Pin_6 | GPIO_Pin_7);
}
```

### 11.3 I2C 数据传输

```c
// 发送起始条件
void I2C_Start(void)
{
    I2CMSCR = 0x81;  // 发送 START
    while(!(I2CMSST & 0x40));  // 等待完成
    I2CMSST = 0x00;  // 清除标志
}

// 发送停止条件
void I2C_Stop(void)
{
    I2CMSCR = 0x86;  // 发送 STOP
    while(!(I2CMSST & 0x40));
    I2CMSST = 0x00;
}

// 发送一个字节
bit I2C_Write_Byte(u8 dat)
{
    I2CTXD = dat;
    I2CMSCR = 0x82;  // 发送数据
    while(!(I2CMSST & 0x40));
    I2CMSST = 0x00;
    
    return (I2CMSST & 0x01);  // 返回 ACK
}

// 接收一个字节
u8 I2C_Read_Byte(bit ack)
{
    I2CMSCR = ack ? 0x83 : 0x84;  // 接收数据 + ACK/NACK
    while(!(I2CMSST & 0x40));
    I2CMSST = 0x00;
    
    return I2CRXD;
}
```

### 11.4 AT24C02 EEPROM 操作示例

```c
#define AT24C02_ADDR  0xA0  // 器件地址

// 写一个字节
void AT24C02_Write_Byte(u8 addr, u8 dat)
{
    I2C_Start();
    I2C_Write_Byte(AT24C02_ADDR);  // 发送器件地址 + 写
    I2C_Write_Byte(addr);           // 发送字节地址
    I2C_Write_Byte(dat);            // 发送数据
    I2C_Stop();
    
    delay_ms(5);  // 等待写入完成
}

// 读一个字节
u8 AT24C02_Read_Byte(u8 addr)
{
    u8 dat;
    
    I2C_Start();
    I2C_Write_Byte(AT24C02_ADDR);  // 发送器件地址 + 写
    I2C_Write_Byte(addr);           // 发送字节地址
    
    I2C_Start();                    // 重新开始
    I2C_Write_Byte(AT24C02_ADDR | 0x01);  // 发送器件地址 + 读
    dat = I2C_Read_Byte(0);         // 读数据（NACK）
    I2C_Stop();
    
    return dat;
}

// 连续写
void AT24C02_Write_Buffer(u8 addr, u8 *buf, u16 len)
{
    u16 i;
    
    I2C_Start();
    I2C_Write_Byte(AT24C02_ADDR);
    I2C_Write_Byte(addr);
    
    for(i=0; i<len; i++)
        I2C_Write_Byte(buf[i]);
    
    I2C_Stop();
    delay_ms(5);
}

// 连续读
void AT24C02_Read_Buffer(u8 addr, u8 *buf, u16 len)
{
    u16 i;
    
    I2C_Start();
    I2C_Write_Byte(AT24C02_ADDR);
    I2C_Write_Byte(addr);
    
    I2C_Start();
    I2C_Write_Byte(AT24C02_ADDR | 0x01);
    
    for(i=0; i<len-1; i++)
        buf[i] = I2C_Read_Byte(1);  // ACK
    
    buf[len-1] = I2C_Read_Byte(0);  // NACK
    I2C_Stop();
}
```

---

## 12. DMA 模块

### 12.1 DMA 通道

AI8051U 提供多个 DMA 通道：

| DMA 通道 | 功能 |
|---------|------|
| DMA_M2M | 内存到内存传输 |
| DMA_ADC | ADC 自动采样传输 |
| DMA_SPI | SPI 自动收发 |
| DMA_UART1~4 | UART 收发 |
| DMA_I2C | I2C 收发 |
| DMA_LCM | LCM 接口传输 |
| DMA_QSPI | QSPI 高速传输 |

### 12.2 DMA 内存拷贝示例

```c
#include "AI8051U_DMA.h"

u8 xdata src_buf[256];
u8 xdata dst_buf[256];

void DMA_M2M_Example(void)
{
    DMA_M2M_InitTypeDef dma;
    
    dma.DMA_Enable = ENABLE;
    dma.DMA_Channel = DMA_M2M_Channel;
    dma.DMA_SRC_Addr = (u16)src_buf;         // 源地址
    dma.DMA_DST_Addr = (u16)dst_buf;         // 目标地址
    dma.DMA_Length = 256;                    // 传输长度
    dma.DMA_INT_Enable = DISABLE;
    
    DMA_M2M_Inilize(&dma);
    
    // 启动传输
    DMA_M2M_CR |= 0x80;
    
    // 等待完成
    while(!(DMA_M2M_STA & 0x01));
    DMA_M2M_STA = 0;
}
```

### 12.3 DMA + ADC 连续采样

```c
u16 xdata adc_buf[256];

void DMA_ADC_Config(void)
{
    // 配置 ADC
    ADC_InitTypeDef adc;
    adc.ADC_Channels = ADC_CH0;
    adc.ADC_Speed = ADC_SPEED_2X16T;
    adc.ADC_Power = ENABLE;
    ADC_Inilize(&adc);
    
    // 配置 DMA
    DMA_ADC_InitTypeDef dma;
    dma.DMA_Enable = ENABLE;
    dma.DMA_Channel = DMA_ADC_Channel;
    dma.DMA_DST_Addr = (u16)adc_buf;
    dma.DMA_Length = 256;
    dma.DMA_INT_Enable = ENABLE;
    
    DMA_ADC_Inilize(&dma);
    
    // 启动 DMA
    DMA_ADC_CR |= 0x80;
    
    // ADC 自动触发
    // 等待中断处理
}

void DMA_ADC_ISR(void) interrupt DMA_ADC_VECTOR
{
    DMA_ADC_STA = 0;
    // DMA 传输完成，adc_buf 中已有 256 个采样值
}
```

### 12.4 DMA + UART 高速传输

```c
u8 xdata uart_tx_buf[512];

void DMA_UART_Send(u8 *buf, u16 len)
{
    DMA_UR1T_InitTypeDef dma;
    
    dma.DMA_Enable = ENABLE;
    dma.DMA_Channel = DMA_UR1T_Channel;
    dma.DMA_SRC_Addr = (u16)buf;
    dma.DMA_Length = len;
    dma.DMA_INT_Enable = ENABLE;
    
    DMA_UART1_TX_Inilize(&dma);
    
    // 启动传输
    DMA_UR1T_CR |= 0x80;
}
```

---

## 13. USB 功能

### 13.1 USB 特性

- **USB 2.0 全速设备**（12Mbps）
- **支持类**: CDC（虚拟串口）、HID（人机接口）
- **端点**: EP0 + 5 个可配置端点
- **供电**: 总线供电或自供电

### 13.2 USB CDC（虚拟串口）

USB CDC 将单片机模拟成一个 COM 口，无需编写驱动程序。

**使用方法：**
```c
// 1. 链接 USB 库
// 在 Keil 工程中添加：
// Driver/stc_usb_cdc_32g.LIB

// 2. 包含头文件
#include "ai_usb.h"

// 3. 初始化 USB
void USB_CDC_Init(void)
{
    // 配置 USB 时钟（48MHz）
    IRC48MCR = 0x80;
    while(!(IRC48MCR & 0x01));
    
    USBCLK = 0x00;  // USB 时钟选择
    
    // 使能 USB
    ENUSB = 1;
    
    // USB 库初始化（在库中实现）
    usb_init();
}

// 4. 主循环中调用
void main(void)
{
    USB_CDC_Init();
    
    while(1)
    {
        usb_process();  // 处理 USB 事务
        
        // 发送数据
        if (usb_cdc_connected())
        {
            usb_cdc_send("Hello USB!\r\n", 12);
        }
        
        // 接收数据
        if (usb_cdc_available())
        {
            u8 dat = usb_cdc_read();
            // 处理接收数据
        }
    }
}
```

### 13.3 USB HID（键盘/鼠标）

```c
// 链接 USB HID 库
// Driver/stc_usb_hid_32g.LIB

#include "ai_usb.h"

void USB_HID_Init(void)
{
    // 时钟配置同上
    usb_hid_init();
}

// HID 键盘示例
void USB_Keyboard_Send(u8 key)
{
    u8 report[8] = {0};
    
    report[2] = key;  // 键值
    usb_hid_send_report(report, 8);
    
    delay_ms(10);
    
    // 释放按键
    report[2] = 0;
    usb_hid_send_report(report, 8);
}

// HID 鼠标示例
void USB_Mouse_Move(s8 x, s8 y)
{
    u8 report[4] = {0};
    
    report[1] = x;  // X 移动
    report[2] = y;  // Y 移动
    usb_hid_send_report(report, 4);
}
```

---

## 14. 其他外设

### 14.1 EEPROM 操作

AI8051U 内部集成 EEPROM，掉电不丢失。

```c
#include "AI8051U_EEPROM.h"

// 读取 EEPROM
u8 EEPROM_Read_Byte(u16 addr)
{
    u8 dat;
    
    IAP_CONTR = 0x80;       // 使能 IAP
    IAP_CMD = 0x01;         // 读命令
    IAP_ADDRH = addr >> 8;
    IAP_ADDRL = addr;
    IAP_TRIG = 0x5A;        // 触发
    IAP_TRIG = 0xA5;
    _nop_();
    dat = IAP_DATA;
    IAP_CONTR = 0;          // 关闭 IAP
    
    return dat;
}

// 写入 EEPROM
void EEPROM_Write_Byte(u16 addr, u8 dat)
{
    IAP_CONTR = 0x80;
    IAP_CMD = 0x02;         // 写命令
    IAP_ADDRH = addr >> 8;
    IAP_ADDRL = addr;
    IAP_DATA = dat;
    IAP_TRIG = 0x5A;
    IAP_TRIG = 0xA5;
    _nop_();
    IAP_CONTR = 0;
}

// 擦除扇区（512 字节）
void EEPROM_Erase_Sector(u16 addr)
{
    IAP_CONTR = 0x80;
    IAP_CMD = 0x03;         // 擦除命令
    IAP_ADDRH = addr >> 8;
    IAP_ADDRL = addr;
    IAP_TRIG = 0x5A;
    IAP_TRIG = 0xA5;
    _nop_();
    IAP_CONTR = 0;
}
```

### 14.2 RTC 实时时钟

```c
#include "AI8051U_RTC.h"

typedef struct
{
    u8 year;
    u8 month;
    u8 day;
    u8 hour;
    u8 minute;
    u8 second;
    u8 week;
} RTC_Time;

void RTC_Init(void)
{
    RTC_InitTypeDef rtc;
    
    rtc.RTC_ClkSel = RTC_CLK_SEL_IRC32K;    // 使用 IRC 32K
    rtc.RTC_Year = 25;                       // 2025
    rtc.RTC_Month = 10;
    rtc.RTC_Day = 11;
    rtc.RTC_Hour = 12;
    rtc.RTC_Minute = 0;
    rtc.RTC_Second = 0;
    rtc.RTC_Week = 5;                        // 星期五
    
    RTC_Inilize(&rtc);
}

void RTC_Read_Time(RTC_Time *time)
{
    time->year = YEAR;
    time->month = MONTH;
    time->day = DAY;
    time->hour = HOUR;
    time->minute = MIN;
    time->second = SEC;
    time->week = WEEK;
}

// 显示时间
void RTC_Display(void)
{
    RTC_Time time;
    
    RTC_Read_Time(&time);
    printf("20%02d-%02d-%02d %02d:%02d:%02d Week:%d\r\n",
           time.year, time.month, time.day,
           time.hour, time.minute, time.second,
           time.week);
}
```

### 14.3 看门狗（WDT）

```c
#include "AI8051U_WDT.h"

void WDT_Init(void)
{
    WDT_InitTypeDef wdt;
    
    wdt.WDT_Timer = WDT_TIMER_32768;  // 溢出时间约 3.2 秒
    wdt.WDT_IDLEEnable = DISABLE;     // Idle 模式也计数
    wdt.WDT_Enable = ENABLE;          // 使能看门狗
    
    WDT_Inilize(&wdt);
}

// 喂狗
void WDT_Feed(void)
{
    WDT_CONTR |= 0x10;  // 清除看门狗计数
}

// 主循环示例
void main(void)
{
    WDT_Init();
    
    while(1)
    {
        // 执行任务
        Task1();
        Task2();
        
        // 定期喂狗
        WDT_Feed();
        
        delay_ms(1000);
    }
}
```

### 14.4 比较器

```c
#include "AI8051U_Compare.h"

void Comparator_Init(void)
{
    CMP_InitTypeDef cmp;
    
    cmp.CMP_EN = ENABLE;                     // 使能比较器
    cmp.CMP_P_Select = CMP_P_SEL_P46;        // P4.6 作正输入
    cmp.CMP_N_Select = CMP_N_SEL_VREF;       // 内部 1.19V 作负输入
    cmp.CMP_OutEnable = ENABLE;              // 输出使能
    cmp.CMP_InvEnable = DISABLE;             // 不反相
    cmp.CMP_RiseIntEnable = ENABLE;          // 上升沿中断
    cmp.CMP_FallIntEnable = DISABLE;         // 下降沿中断
    cmp.CMP_Polity = Priority_0;
    
    CMP_Inilize(&cmp);
}

// 中断服务程序
void CMP_ISR(void) interrupt CMP_VECTOR
{
    if (CMPIF)
    {
        CMPIF = 0;  // 清除标志
        
        // 比较器输出变化
        if (CMPRES)
        {
            // P4.6 > 1.19V
        }
        else
        {
            // P4.6 < 1.19V
        }
    }
}
```

---

## 15. 常见问题

### 15.1 编译问题

**Q: 编译提示 "undefined symbol"**

A: 检查是否添加了所有需要的 `.c` 文件到工程，特别是 `*_Isr.c` 中断文件。

**Q: 提示内存溢出**

A: 
1. 减少全局变量使用
2. 在 BL51 设置中增大 XDATA 空间
3. 使用 `code` 关键字存储常量数据

```c
// 将常量表存储在 Flash 中
u8 code table[256] = {...};
```

### 15.2 下载问题

**Q: STC-ISP 无法连接单片机**

A:
1. 检查串口号是否正确
2. 检查单片机供电
3. 尝试冷启动下载（断电重新上电）
4. 降低波特率

**Q: 下载后程序不运行**

A:
1. 检查是否勾选了"复位时运行用户程序"
2. 检查看门狗设置
3. 检查时钟源配置

### 15.3 串口问题

**Q: 串口乱码**

A:
1. 检查波特率设置是否正确
2. 检查主频配置
3. 使用 BaudRateDouble = DISABLE
4. 对于高波特率，使用外部晶振

**Q: Printf 不输出**

A:
1. 检查 `PRINTF_SELECT` 定义
2. 确认串口已初始化
3. 检查是否链接了 printf 库

### 15.4 中断问题

**Q: 中断不响应**

A:
1. 检查是否执行了 `EA = 1`
2. 检查中断优先级设置
3. 确认中断向量号正确
4. 检查是否清除了中断标志

**Q: 中断嵌套问题**

A:
```c
// 使能中断嵌套
EA = 1;

// 在高优先级中断中
void High_Priority_ISR(void) interrupt XX
{
    EA = 1;  // 允许更高优先级中断嵌套
    // ...
    EA = 1;  // 退出前恢复
}
```

### 15.5 外设问题

**Q: ADC 读数不稳定**

A:
1. GPIO 配置为高阻输入
2. 增加采样时间
3. 多次采样取平均
4. 添加硬件滤波电路

**Q: SPI 通信异常**

A:
1. 检查 CPOL/CPHA 设置
2. 降低 SPI 速度
3. 检查 GPIO 配置
4. 使用示波器观察波形

**Q: I2C 无 ACK**

A:
1. 检查器件地址
2. 检查上拉电阻（2.2K~10K）
3. 降低 I2C 速度
4. 检查连线

---

## 16. API 参考

### 16.1 GPIO API

```c
// GPIO 初始化
u8 GPIO_Inilize(u8 GPIO, GPIO_InitTypeDef *GPIOx);
// 参数：
//   GPIO: GPIO_P0 ~ GPIO_P7
//   GPIOx->Mode: GPIO_PullUp, GPIO_HighZ, GPIO_OUT_OD, GPIO_OUT_PP
//   GPIOx->Pin: GPIO_Pin_0 ~ GPIO_Pin_7

// GPIO 中断初始化
u8 GPIO_INT_Inilize(u8 GPIO, GPIO_Int_InitTypeDef *GPIOx);
// 参数：
//   GPIOx->Mode: GPIO_FALLING_EDGE, GPIO_RISING_EDGE, GPIO_LOW_LEVEL, GPIO_HIGH_LEVEL
//   GPIOx->IntEnable: ENABLE/DISABLE
//   GPIOx->Priority: Priority_0 ~ Priority_3
```

### 16.2 UART API

```c
// UART 初始化
u8 UART_Configuration(u8 UARTx, COMx_InitDefine *COMx);
// 参数：
//   UARTx: UART1 ~ UART4
//   COMx->UART_Mode: UART_ShiftRight, UART_8bit_BRTx, UART_9bit, UART_9bit_BRTx
//   COMx->UART_BaudRate: 波特率值
//   COMx->ParityMode: PARITY_NONE, PARITY_EVEN, PARITY_ODD

// 发送数据
void TX1_write2buff(u8 dat);   // UART1
void TX2_write2buff(u8 dat);   // UART2
void TX3_write2buff(u8 dat);   // UART3
void TX4_write2buff(u8 dat);   // UART4

// 发送字符串
void PrintString1(u8 *puts);
void PrintString2(u8 *puts);
void PrintString3(u8 *puts);
void PrintString4(u8 *puts);
```

### 16.3 Timer API

```c
// 定时器初始化
u8 Timer_Inilize(u8 TIMx, TIM_InitTypeDef *TIMx);
// 参数：
//   TIMx: TIM_Timer0 ~ TIM_Timer4, TIM_Timer11
//   TIMx->TIM_Mode: TIM_16BitAutoReload, TIM_16Bit, TIM_8BitAutoReload, TIM_Split
//   TIMx->TIM_ClkSource: TIM_CLOCK_1T, TIM_CLOCK_12T, TIM_CLOCK_Ext
//   TIMx->TIM_ClkOut: ENABLE/DISABLE
```

### 16.4 ADC API

```c
// ADC 初始化
u8 ADC_Inilize(ADC_InitTypeDef *ADCx);
// 参数：
//   ADCx->ADC_Channels: ADC_CH0 ~ ADC_CH15
//   ADCx->ADC_Speed: ADC_SPEED_2X1T ~ ADC_SPEED_2X512T
//   ADCx->ADC_AdjResult: ADC_RIGHT_JUSTIFIED, ADC_LEFT_JUSTIFIED
```

### 16.5 PWM API

```c
// PWM 初始化
u8 PWMx_Configuration(u8 PWMx, PWMx_InitDefine *PWMx);
// 参数：
//   PWMx: PWM1 ~ PWM8
//   PWMx->PWM_Mode: CCMRn_PWM_MODE1, CCMRn_PWM_MODE2
//   PWMx->PWM_Period: PWM 周期
//   PWMx->PWM_Duty: 占空比值
//   PWMx->PWM_DeadTime: 死区时间
```

### 16.6 SPI API

```c
// SPI 初始化
u8 SPI_Inilize(SPI_InitTypeDef *SPIx);
// 参数：
//   SPIx->SPI_Mode: SPI_Mode_Master, SPI_Mode_Slave
//   SPIx->SPI_CPOL: SPI_CPOL_Low, SPI_CPOL_High
//   SPIx->SPI_CPHA: SPI_CPHA_1Edge, SPI_CPHA_2Edge
//   SPIx->SPI_Speed: SPI_Speed_4 ~ SPI_Speed_128
```

### 16.7 I2C API

```c
// I2C 初始化
u8 I2C_Init(I2C_InitTypeDef *I2Cx);
// 参数：
//   I2Cx->I2C_Mode: I2C_Mode_Master, I2C_Mode_Slave
//   I2Cx->I2C_Speed: I2C 频率（Hz）
//   I2Cx->I2C_SlaveAddr: 从机地址（从机模式）
```

---

## 附录 A：示例工程导航

| 序号 | 工程名称 | 路径 | 学习要点 |
|-----|---------|------|---------|
| 01 | IO 跑马灯 | `独立程序/01-IO-跑马灯/` | GPIO 基础 |
| 02 | 定时器测试 | `独立程序/02-Timer0-Timer1-Timer2-Timer3-Timer4测试程序/` | 定时器配置 |
| 03 | 外中断测试 | `独立程序/03-外中断INT0-INT1-INT2-INT3-INT4测试/` | 中断处理 |
| 05 | 串口通信 | `独立程序/05-串口1中断模式与电脑收发测试/` | UART 使用 |
| 10 | ADC 转换 | `独立程序/10-多路ADC转换-串口输出结果/` | ADC 采样 |
| 12 | EEPROM 读写 | `独立程序/12-通过串口发送命令读写EEPROM测试程序/` | 数据存储 |
| 15 | I2C AT24C02 | `独立程序/15.1-I2C主机模式访问AT24C02程序/` | I2C 通信 |
| 17 | PWM 呼吸灯 | `独立程序/17-高级PWM1-PWM2-PWM3-PWM4驱动P0口呼吸灯实验程序/` | PWM 应用 |
| 20 | SPI Flash | `独立程序/20.1-串口发指令通过SPI访问Flash芯片/` | SPI 应用 |
| 21 | DMA + ADC | `独立程序/21-ADC采样数据自动存入DMA-串口输出结果/` | DMA 使用 |
| - | 综合程序 | `综合程序/` | 完整项目架构 |

---

## 附录 B：常用宏定义速查

```c
// ===== 系统控制 =====
WTST = 0;              // CPU 最高速
EAXSFR();              // 使能扩展寄存器
EA = 1;                // 使能总中断

// ===== GPIO =====
P0_MODE_OUT_PP(pin);   // 推挽输出
P0_MODE_IN_HIZ(pin);   // 高阻输入
P0_PULL_UP_ENABLE(pin); // 使能上拉

// ===== 位定义 =====
#define BIT0  0x01
#define BIT7  0x80
#define ENABLE  1
#define DISABLE 0

// ===== 延时 =====
delay_ms(n);           // 延时 n 毫秒
delay_us(n);           // 延时 n 微秒
```

---

## 附录 C：引脚复用表

| 引脚 | 功能1 | 功能2 | 功能3 | 功能4 |
|------|-------|-------|-------|-------|
| P3.0 | GPIO | UART1_RX | - | - |
| P3.1 | GPIO | UART1_TX | - | - |
| P1.6 | GPIO | I2C_SCL | - | - |
| P1.7 | GPIO | I2C_SDA | - | - |
| P1.2 | GPIO | SPI_MOSI | - | - |
| P1.3 | GPIO | SPI_SCLK | - | - |
| P1.4 | GPIO | SPI_SS | - | - |
| P1.5 | GPIO | SPI_MISO | - | - |
| P2.0~P2.7 | GPIO | PWM1~8 | - | - |

---

## 附录 D：参考资料

1. **AI8051U 数据手册** - 芯片详细规格
2. **AI8051U 库函数使用说明-20250410.pdf** - 官方库函数说明
3. **Keil C51 用户手册** - 编译器使用
4. **STC-ISP 软件** - 下载工具

---

## 结语

本文档涵盖了 AI8051U 软件库的主要功能和使用方法。建议您：

1. **从简单开始** - 按照示例工程顺序学习
2. **多实践** - 在开发板上验证每个功能
3. **查阅官方文档** - 遇到问题查看 PDF 说明书
4. **参考综合程序** - 学习专业的代码架构

祝您开发顺利！

---

**文档版本**: V1.0  
**最后更新**: 2025-10-11  
**反馈联系**: www.STCAI.com

