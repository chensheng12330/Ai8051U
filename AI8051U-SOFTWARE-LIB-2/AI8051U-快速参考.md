# AI8051U 快速参考指南

> 快速查找常用代码片段和配置

---

## 📋 目录

- [系统初始化模板](#系统初始化模板)
- [GPIO 快速配置](#gpio-快速配置)
- [串口快速配置](#串口快速配置)
- [定时器快速配置](#定时器快速配置)
- [ADC 快速配置](#adc-快速配置)
- [PWM 快速配置](#pwm-快速配置)
- [常用计算公式](#常用计算公式)
- [中断向量表](#中断向量表)
- [寄存器速查](#寄存器速查)

---

## 系统初始化模板

### 最小 main 函数模板

```c
#include "config.h"

void main(void)
{
    // 系统初始化（必需）
    WTST = 0;        // CPU 最高速
    EAXSFR();        // 使能扩展寄存器
    CKCON = 0;       // XRAM 高速访问
    SET_TPS();       // 设置时间单位
    
    // 外设初始化
    GPIO_Init();
    UART1_Init();
    Timer0_Init();
    
    EA = 1;          // 使能总中断
    
    // 主循环
    while(1)
    {
        // 您的代码
    }
}
```

### 完整初始化模板（带看门狗）

```c
void System_Init(void)
{
    // 基础系统
    WTST = 0;
    EAXSFR();
    CKCON = 0;
    SET_TPS();
    IRC_Debounce(0x80);
    
    // 时钟配置（可选）
    HIRCCR = 0x80;              // 使能 IRC
    while(!(HIRCCR & 0x01));    // 等待稳定
    CLKSEL = 0x00;              // 选择 IRC
    
    // 看门狗（可选）
    WDT_CONTR = 0x35;           // 使能 WDT，溢出时间约 3.2s
    
    EA = 1;
}
```

---

## GPIO 快速配置

### 常用 GPIO 模式

```c
// 推挽输出（LED、继电器）
P0_MODE_OUT_PP(GPIO_Pin_0);
P00 = 0;  // 输出低

// 高阻输入（按键、ADC）
P1_MODE_IN_HIZ(GPIO_Pin_0);
if(P10 == 0) { /* 按键按下 */ }

// 准双向口（通用 I/O）
P2_MODE_IO_PU(GPIO_Pin_All);

// 开漏输出（I2C、总线）
P1_MODE_OUT_OD(GPIO_Pin_6 | GPIO_Pin_7);
P1_PULL_UP_ENABLE(GPIO_Pin_6 | GPIO_Pin_7);
```

### 按键检测（带消抖）

```c
u8 Key_Scan(void)
{
    if(P32 == 0)  // 按键按下
    {
        delay_ms(10);  // 消抖
        if(P32 == 0)
        {
            while(P32 == 0);  // 等待释放
            return 1;
        }
    }
    return 0;
}
```

### LED 闪烁

```c
while(1)
{
    P00 = 0;  delay_ms(500);  // LED 亮
    P00 = 1;  delay_ms(500);  // LED 灭
}
```

---

## 串口快速配置

### UART1 标准配置（115200）

```c
void UART1_Init(void)
{
    COMx_InitDefine com;
    
    com.UART_Mode = UART_8bit_BRTx;
    com.UART_BRT_Use = BRT_Timer1;
    com.UART_BaudRate = 115200;
    com.UART_RxEnable = ENABLE;
    com.BaudRateDouble = DISABLE;
    com.ParityMode = PARITY_NONE;
    
    UART_Configuration(UART1, &com);
    NVIC_UART1_Init(ENABLE, Priority_1);
    EA = 1;
    
    // GPIO 配置（自动，不需要手动配置）
}
```

### 串口发送

```c
// 发送单字节
TX1_write2buff(0x55);

// 发送字符串
PrintString1("Hello\r\n");

// Printf（需要在 AI8051U_UART.h 配置）
printf("Value: %d\r\n", value);
```

### 串口接收（中断）

```c
void UART1_ISR(void) interrupt UART1_VECTOR
{
    if(RI)
    {
        CLR_RI();
        u8 dat = SBUF;
        // 处理接收数据
    }
    
    if(TI)
    {
        CLR_TI();
        // 处理发送完成
    }
}
```

### 多串口同时使用

```c
// 初始化 4 个串口
UART1_Config();  // 115200
UART2_Config();  // 9600
UART3_Config();  // 19200
UART4_Config();  // 38400

// 分别发送
PrintString1("UART1\r\n");
PrintString2("UART2\r\n");
PrintString3("UART3\r\n");
PrintString4("UART4\r\n");
```

---

## 定时器快速配置

### Timer0 定时 1ms 中断

```c
void Timer0_Init(void)
{
    TIM_InitTypeDef tim;
    
    tim.TIM_Mode = TIM_16BitAutoReload;
    tim.TIM_ClkSource = TIM_CLOCK_1T;
    tim.TIM_ClkOut = DISABLE;
    tim.TIM_Value = 65536 - (MAIN_Fosc / 1000);  // 1ms
    tim.TIM_Run = ENABLE;
    
    Timer_Inilize(TIM_Timer0, &tim);
    NVIC_Timer0_Init(ENABLE, Priority_1);
    EA = 1;
}

void TM0_ISR(void) interrupt TMR0_VECTOR
{
    // 每 1ms 执行一次
}
```

### 常用定时值

```c
// 40MHz 主频，1T 模式
65536 - 40000     // 1ms
65536 - 4000      // 100us
65536 - 400       // 10us

// 24MHz 主频，1T 模式
65536 - 24000     // 1ms
65536 - 2400      // 100us

// 12MHz 主频，12T 模式
65536 - 1000      // 1ms
```

### Timer 时基生成

```c
// 使用 Timer0 生成精确时基
volatile u16 sys_tick_ms = 0;

void TM0_ISR(void) interrupt TMR0_VECTOR
{
    sys_tick_ms++;
}

// 使用方式
u16 start_time = sys_tick_ms;
while((sys_tick_ms - start_time) < 1000);  // 等待 1 秒
```

---

## ADC 快速配置

### ADC 基础配置

```c
void ADC_Init(void)
{
    ADC_InitTypeDef adc;
    
    adc.ADC_Channels = ADC_CH0;
    adc.ADC_Speed = ADC_SPEED_2X16T;
    adc.ADC_Power = ENABLE;
    adc.ADC_AdjResult = ADC_RIGHT_JUSTIFIED;
    adc.ADC_Interrupt = DISABLE;
    
    ADC_Inilize(&adc);
    
    // GPIO 配置为高阻（必需）
    P1_MODE_IN_HIZ(GPIO_Pin_0);
}
```

### ADC 单次采样

```c
u16 ADC_Read(u8 channel)
{
    ADC_CONTR = (ADC_CONTR & 0xF0) | channel;
    ADC_START = 1;
    
    _nop_(); _nop_(); _nop_(); _nop_();
    
    while(!ADC_FLAG);
    ADC_FLAG = 0;
    
    return (ADC_RES << 8) | ADC_RESL;
}
```

### ADC 转电压

```c
// ADC 值转电压（mV）
// VCC = 5000mV，12 位 ADC
u16 adc_val = ADC_Read(ADC_CH0);
u16 voltage = (u32)adc_val * 5000 / 4096;

printf("Voltage: %d.%03d V\r\n", voltage/1000, voltage%1000);
```

### 多次采样滤波

```c
u16 ADC_Read_Average(u8 channel, u8 times)
{
    u32 sum = 0;
    u8 i;
    
    for(i=0; i<times; i++)
    {
        sum += ADC_Read(channel);
        delay_ms(5);
    }
    
    return sum / times;
}
```

---

## PWM 快速配置

### PWM 基础配置（1kHz，50%）

```c
void PWM1_Init(void)
{
    PWMx_InitDefine pwm;
    
    pwm.PWM_Mode = CCMRn_PWM_MODE1;
    pwm.PWM_Duty = 20000;                    // 50%
    pwm.PWM_EnoSelect = ENO_PWM1P;
    pwm.PWM_Period = 40000;                  // 1kHz
    pwm.PWM_DeadTime = 0;
    pwm.PWM_MainOutEnable = ENABLE;
    pwm.PWM_CEN_Enable = ENABLE;
    
    PWMx_Configuration(PWM1, &pwm);
    P2_MODE_OUT_PP(GPIO_Pin_0);
}
```

### 占空比调节

```c
// 设置占空比（0-100%）
void PWM_SetDuty(u8 percent)
{
    u16 duty = (u32)40000 * percent / 100;
    PWMA_CCR1H = duty >> 8;
    PWMA_CCR1L = duty;
}

// 使用
PWM_SetDuty(25);   // 25%
PWM_SetDuty(75);   // 75%
```

### 呼吸灯

```c
void Breathing_LED(void)
{
    u8 i;
    while(1)
    {
        for(i=0; i<100; i++) { PWM_SetDuty(i); delay_ms(10); }
        for(i=100; i>0; i--) { PWM_SetDuty(i); delay_ms(10); }
    }
}
```

### PWM 频率计算

```c
// PWM 频率 = 主频 / PWM_Period
// 40MHz，1kHz  → PWM_Period = 40000
// 40MHz，10kHz → PWM_Period = 4000
// 40MHz，100Hz → PWM_Period = 400000（需调整预分频）
```

---

## 常用计算公式

### 定时器计算

```c
// 定时时间（秒） = (65536 - TIM_Value) / (主频 / 分频)

// 例：40MHz，1T，定时 1ms
TIM_Value = 65536 - (40000000 / 1000) = 25536

// 例：24MHz，12T，定时 10ms  
TIM_Value = 65536 - (24000000 / 12 / 100) = 45536
```

### 串口波特率计算

```c
// 使用 Timer1，8 位自动重载，不加倍
// TH1 = 256 - (主频 / 波特率 / 32)

// 例：40MHz，115200
TH1 = TL1 = 256 - (40000000 / 115200 / 32) = 245 (0xF5)

// 例：11.0592MHz，9600（标准）
TH1 = TL1 = 256 - (11059200 / 9600 / 32) = 220 (0xDC)
```

### PWM 频率/占空比

```c
// PWM 频率 = 主频 / 预分频 / PWM_Period
// 占空比 = PWM_Duty / PWM_Period * 100%

// 例：40MHz，不分频，1kHz，50%
PWM_Period = 40000
PWM_Duty = 20000
```

### ADC 电压转换

```c
// 12 位 ADC，参考电压 VCC
// 电压（mV） = ADC值 * VCC / 4096

// 10 位 ADC
// 电压（mV） = ADC值 * VCC / 1024
```

---

## 中断向量表

| 中断源 | 向量号 | 宏定义 | 优先级寄存器 |
|-------|--------|--------|-------------|
| INT0 | 0 | INT0_VECTOR | IP, IPH |
| Timer0 | 1 | TMR0_VECTOR | IP, IPH |
| INT1 | 2 | INT1_VECTOR | IP, IPH |
| Timer1 | 3 | TMR1_VECTOR | IP, IPH |
| UART1 | 4 | UART1_VECTOR | IP, IPH |
| ADC | 5 | ADC_VECTOR | IP, IPH |
| UART2 | 8 | UART2_VECTOR | IP2, IP2H |
| SPI | 9 | SPI_VECTOR | IP2, IP2H |
| Timer2 | 12 | TMR2_VECTOR | IE2 |
| UART3 | 17 | UART3_VECTOR | IE2 |
| UART4 | 18 | UART4_VECTOR | IE2 |
| Timer3 | 19 | TMR3_VECTOR | IE2 |
| Timer4 | 20 | TMR4_VECTOR | IE2 |
| I2C | 24 | I2C_VECTOR | IP2 |
| USB | 25 | USB_VECTOR | IP2 |
| RTC | 36 | RTC_VECTOR | IP3 |

### 中断模板

```c
// 中断服务程序模板
void XXX_ISR(void) interrupt XXX_VECTOR
{
    // 清除中断标志（如果需要）
    XXX_FLAG = 0;
    
    // 处理中断
    
}

// 中断优先级配置
NVIC_XXX_Init(ENABLE, Priority_1);
EA = 1;
```

---

## 寄存器速查

### 系统控制寄存器

```c
WTST       // 程序指令等待时间
EAXFR      // 扩展 SFR 访问使能（bit7）
CKCON      // 时钟控制
CLKSEL     // 时钟源选择
CLKDIV     // 时钟分频
```

### GPIO 寄存器

```c
P0~P7      // 端口数据寄存器
P0M0~P7M0  // 端口模式寄存器 0
P0M1~P7M1  // 端口模式寄存器 1
P0PU~P7PU  // 上拉使能
P0PD~P7PD  // 下拉使能
P0SR~P7SR  // 转换速率控制
P0DR~P7DR  // 驱动能力控制
```

### 中断寄存器

```c
EA         // 总中断使能（IE.7）
IE         // 中断使能寄存器
IE2        // 中断使能寄存器 2
IP         // 中断优先级
IP2        // 中断优先级 2
IPH        // 中断优先级高字节
IP2H       // 中断优先级 2 高字节
```

### 定时器寄存器

```c
TCON       // 定时器控制寄存器
TMOD       // 定时器模式寄存器
TH0, TL0   // Timer0 高/低字节
TH1, TL1   // Timer1 高/低字节
TH2, TL2   // Timer2 高/低字节
TH3, TL3   // Timer3 高/低字节
TH4, TL4   // Timer4 高/低字节
```

### 串口寄存器

```c
SCON       // 串口 1 控制寄存器
SBUF       // 串口 1 数据缓冲
S2CON      // 串口 2 控制寄存器
S2BUF      // 串口 2 数据缓冲
S3CON      // 串口 3 控制寄存器
S3BUF      // 串口 3 数据缓冲
S4CON      // 串口 4 控制寄存器
S4BUF      // 串口 4 数据缓冲
```

---

## 常用代码片段

### Delay 延时

```c
// 毫秒延时（40MHz）
void delay_ms(u16 ms)
{
    u16 i, j;
    for(i=0; i<ms; i++)
        for(j=0; j<5000; j++);
}

// 微秒延时（40MHz）
void delay_us(u16 us)
{
    while(us--);
}
```

### 数组操作

```c
// 查找最大值
u16 Find_Max(u16 *buf, u8 len)
{
    u16 max = buf[0];
    u8 i;
    for(i=1; i<len; i++)
        if(buf[i] > max) max = buf[i];
    return max;
}

// 计算平均值
u16 Calculate_Average(u16 *buf, u8 len)
{
    u32 sum = 0;
    u8 i;
    for(i=0; i<len; i++)
        sum += buf[i];
    return sum / len;
}

// 冒泡排序
void Bubble_Sort(u16 *buf, u8 len)
{
    u8 i, j;
    u16 temp;
    for(i=0; i<len-1; i++)
        for(j=0; j<len-1-i; j++)
            if(buf[j] > buf[j+1])
            {
                temp = buf[j];
                buf[j] = buf[j+1];
                buf[j+1] = temp;
            }
}
```

### 字符串处理

```c
// 字符串长度
u8 String_Length(u8 *str)
{
    u8 len = 0;
    while(str[len] != '\0') len++;
    return len;
}

// 字符串拷贝
void String_Copy(u8 *dst, u8 *src)
{
    while(*src != '\0')
        *dst++ = *src++;
    *dst = '\0';
}

// 字符串比较
bit String_Compare(u8 *str1, u8 *str2)
{
    while(*str1 != '\0' && *str2 != '\0')
    {
        if(*str1 != *str2) return 0;
        str1++;
        str2++;
    }
    return (*str1 == *str2);
}
```

### 数值转换

```c
// 整数转字符串
void Int_To_String(u16 num, u8 *str)
{
    u8 i = 0, j;
    u8 temp[6];
    
    if(num == 0)
    {
        str[0] = '0';
        str[1] = '\0';
        return;
    }
    
    while(num > 0)
    {
        temp[i++] = num % 10 + '0';
        num /= 10;
    }
    
    for(j=0; j<i; j++)
        str[j] = temp[i-1-j];
    str[i] = '\0';
}

// 十六进制字节转字符串
void Hex_To_String(u8 num, u8 *str)
{
    const u8 hex_table[] = "0123456789ABCDEF";
    str[0] = hex_table[num >> 4];
    str[1] = hex_table[num & 0x0F];
    str[2] = '\0';
}
```

---

## 调试技巧

### 串口打印调试信息

```c
#define DEBUG_PRINT(fmt, ...) printf("[DEBUG] " fmt "\r\n", ##__VA_ARGS__)

// 使用
DEBUG_PRINT("Value: %d", value);
DEBUG_PRINT("ADC: 0x%04X", adc_val);
```

### LED 指示状态

```c
#define LED_ON()    P00 = 0
#define LED_OFF()   P00 = 1
#define LED_TOGGLE() P00 = !P00

// 闪烁指示错误
void Error_Blink(u8 times)
{
    u8 i;
    for(i=0; i<times; i++)
    {
        LED_ON();  delay_ms(100);
        LED_OFF(); delay_ms(100);
    }
    delay_ms(500);
}
```

### 看门狗测试

```c
// 测试看门狗是否工作
void WDT_Test(void)
{
    WDT_CONTR = 0x35;  // 使能看门狗
    
    while(1)
    {
        // 不喂狗，等待复位
        delay_ms(5000);
    }
}
```

---

## 项目模板

### 工程文件组织

```
MyProject/
├── Driver/              # 驱动层
│   ├── AI8051U_GPIO.c/h
│   ├── AI8051U_UART.c/h
│   └── ...
├── User/                # 用户层
│   ├── main.c
│   ├── app.c/h
│   └── config.h
├── Hardware/            # 硬件层
│   ├── led.c/h
│   ├── key.c/h
│   └── lcd.c/h
└── Project.uvproj       # Keil 工程
```

### Makefile 模板（可选）

```makefile
# AI8051U Makefile
PROJECT = MyProject
MCU = AI8051U

# 源文件
SRCS = main.c \
       Driver/AI8051U_GPIO.c \
       Driver/AI8051U_UART.c

# 包含路径
INCS = -I Driver/ -I User/

# 编译选项
CFLAGS = -O2

# 目标
all: $(PROJECT).hex

$(PROJECT).hex: $(SRCS)
	C51 $(CFLAGS) $(INCS) $(SRCS)
	BL51 $(PROJECT).obj
	OH51 $(PROJECT).abs

clean:
	rm -f *.obj *.hex *.lst
```

---

## 常见错误及解决

| 错误现象 | 可能原因 | 解决方法 |
|---------|---------|---------|
| 程序不运行 | 未初始化 | 检查 WTST、EAXSFR() |
| 串口乱码 | 波特率错误 | 检查主频和波特率设置 |
| ADC 读数 0 | GPIO 未配置 | 配置为高阻输入 |
| PWM 无输出 | GPIO 模式错误 | 配置为推挽输出 |
| 中断不响应 | EA 未使能 | EA = 1 |
| 内存溢出 | 数组太大 | 使用 xdata 关键字 |

---

## 实用宏定义

```c
// 位操作
#define SetBit(x, y)    ((x) |= (1 << (y)))
#define ClrBit(x, y)    ((x) &= ~(1 << (y)))
#define GetBit(x, y)    (((x) >> (y)) & 1)

// 数值操作
#define ABS(x)          ((x) > 0 ? (x) : -(x))
#define MAX(a, b)       ((a) > (b) ? (a) : (b))
#define MIN(a, b)       ((a) < (b) ? (a) : (b))
#define CONSTRAIN(x, a, b)  ((x) < (a) ? (a) : ((x) > (b) ? (b) : (x)))

// 数组长度
#define ARRAY_SIZE(a)   (sizeof(a) / sizeof(a[0]))

// 字节操作
#define BYTE_H(n)       ((u8)(((u16)(n) >> 8) & 0xFF))
#define BYTE_L(n)       ((u8)((u16)(n) & 0xFF))
#define MAKE_WORD(h, l) (((u16)(h) << 8) | (u8)(l))
```

---

**提示**: 
- 将此文档保存在项目根目录，方便随时查阅
- 建议结合《AI8051U-使用文档.md》详细学习
- 更多示例请参考 `独立程序/` 目录下的工程

---

**快速参考版本**: V1.0  
**最后更新**: 2025-10-11

