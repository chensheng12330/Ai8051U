# 外部中断按键模块使用说明

## 模块概述

**模块名称：** app_intKey  
**创建时间：** 2025-10-21  
**版本：** V1.0  
**作者：** Sherwin.Chen

---

## 功能特性

### 支持的功能
- ✅ 4个独立按键（INT0/INT1/INT2/INT3）
- ✅ 下降沿中断触发（硬件消抖）
- ✅ 软件消抖（20ms确认）
- ✅ 短按检测（<500ms）
- ✅ 长按检测（>500ms）
- ✅ 长按重复（每200ms触发）
- ✅ 可配置启用/禁用

### 技术参数
- **中断响应时间：** <5μs
- **消抖时间：** 20ms
- **长按判定：** 500ms
- **重复间隔：** 200ms
- **任务周期：** 10ms

---

## 硬件连接

### 按键接线方式

```
AI8051U         按键         GND
─────────      ──────       ─────
P3.2 (INT0) ──┤ 按键1 ├──── GND
P3.3 (INT1) ──┤ 按键2 ├──── GND
P3.6 (INT2) ──┤ 按键3 ├──── GND
P3.7 (INT3) ──┤ 按键4 ├──── GND
```

### 电路说明
- **按键类型：** 按下接GND（低电平有效）
- **上拉电阻：** IO内部上拉（已配置）或外接10K上拉
- **IO模式：** 准双向口（默认配置）

---

## 软件配置

### 启用/禁用模块

**在 `Config.h` 中配置：**
```c
// 启用外部中断按键
#define ENABLE_INT_KEY  1  // 1=启用, 0=禁用

// 禁用外部中断按键
#define ENABLE_INT_KEY  0
```

**效果：**
- `ENABLE_INT_KEY = 1`：编译包含intKey模块
- `ENABLE_INT_KEY = 0`：不编译intKey代码，节省空间

---

## API使用

### 全局变量

```c
extern u8 intKeyCode;    // 按键码: 1-4对应INT0-INT3, 0=无按键
extern u8 intKeyEvent;   // 事件: 0=无, 1=短按, 2=长按, 3=重复
extern u8 intKeyState;   // 状态: 0=空闲, 1=按下, 2=长按, 3=释放
```

### 按键码定义

| 宏定义 | 值 | 对应引脚 | 说明 |
|--------|---|---------|------|
| `KEY_INT0` | 1 | P3.2 | 按键1 |
| `KEY_INT1` | 2 | P3.3 | 按键2 |
| `KEY_INT2` | 3 | P3.6 | 按键3 |
| `KEY_INT3` | 4 | P3.7 | 按键4 |

### 事件类型

| 宏定义 | 值 | 说明 |
|--------|---|------|
| `KEY_EVENT_NONE` | 0 | 无事件 |
| `KEY_EVENT_SHORT` | 1 | 短按事件 |
| `KEY_EVENT_LONG` | 2 | 长按事件 |
| `KEY_EVENT_REPEAT` | 3 | 长按重复 |

---

## 使用示例

### 示例1：简单的按键功能

**在 `app_intKey.c` 的 `Sample_intKey()` 函数中修改：**

```c
if(intKeyEvent == KEY_EVENT_SHORT)
{
    switch(intKeyCode)
    {
        case KEY_INT0:  // 按键1短按
            // 您的功能代码
            if(++usrHour >= 24) usrHour = 0;
            DisplayRTC();
            printf("Hour +1\r\n");
            break;
            
        case KEY_INT1:  // 按键2短按
            if(--usrHour >= 24) usrHour = 23;
            DisplayRTC();
            printf("Hour -1\r\n");
            break;
            
        case KEY_INT2:  // 按键3短按
            if(++usrMinute >= 60) usrMinute = 0;
            DisplayRTC();
            printf("Minute +1\r\n");
            break;
            
        case KEY_INT3:  // 按键4短按
            if(--usrMinute >= 60) usrMinute = 59;
            DisplayRTC();
            printf("Minute -1\r\n");
            break;
    }
    
    intKeyCode = 0;
}
```

---

### 示例2：长按快速调整

```c
if(intKeyEvent == KEY_EVENT_LONG)
{
    // 长按首次触发
    printf("Key%d Long Press START\r\n", intKeyCode);
}
else if(intKeyEvent == KEY_EVENT_REPEAT)
{
    // 长按重复（每200ms）
    switch(intKeyCode)
    {
        case KEY_INT0:  // 长按快速加
            if(++usrHour >= 24) usrHour = 0;
            DisplayRTC();
            break;
            
        case KEY_INT1:  // 长按快速减
            if(--usrHour >= 24) usrHour = 23;
            DisplayRTC();
            break;
    }
}
```

---

## 工作原理

### 时序图

```
按键按下            短按释放              长按持续
  │                   │                    │
  ▼                   ▼                    ▼
┌─────┐          ┌─────┐              ┌─────────────┐
│ INT │          │释放 │              │   继续按下   │
│ 触发│          │     │              │             │
└──┬──┘          └──┬──┘              └──────┬──────┘
   │                │                        │
   ├─ 0ms          ├─ <500ms                ├─ >500ms
   ├─ 中断标记      ├─ 短按事件              ├─ 长按事件
   ├─ 20ms消抖     │                        ├─ +200ms
   └─ 确认按下      └─ 清除状态              └─ 重复事件
```

### 状态机

```
状态转换：
  空闲 (IDLE)
    │
    ├─ 中断触发 → 按下 (PRESS)
    │               │
    │               ├─ 释放(<500ms) → 短按事件 → 空闲
    │               │
    │               └─ 持续(>500ms) → 长按 (HOLD)
    │                                   │
    │                                   ├─ 继续按 → 重复事件
    │                                   │
    │                                   └─ 释放 → 空闲
    └─────────────────────────────────────┘
```

---

## 参数配置

### 可调节参数

**在 `app_intKey.c` 中修改：**

```c
// 消抖时间（默认20ms）
#define KEY_DEBOUNCE_TIME    20    // 建议10-50ms

// 长按判定时间（默认500ms）
#define KEY_LONG_PRESS_TIME  500   // 建议300-1000ms

// 长按重复间隔（默认200ms）
#define KEY_REPEAT_TIME      200   // 建议100-500ms
```

---

## 性能开销

### 资源占用

| 资源 | 占用 | 说明 |
|------|------|------|
| **Flash** | ~1KB | 代码空间 |
| **RAM** | ~15B | 全局变量 |
| **中断** | 4个 | INT0-3 |
| **任务** | 1个 | 10ms周期 |
| **CPU占用** | <1% | 极低 |

### 中断执行时间
```
INT0-3中断服务程序：
  - 仅设置标志和记录按键
  - 执行时间：<5μs
  - 不影响任务调度
```

---

## 与其他按键模块对比

| 特性 | ADC按键 | 矩阵按键 | 外部中断按键 |
|------|---------|---------|-------------|
| **按键数量** | 1-16个 | 4×4=16个 | 4个 |
| **响应速度** | 10ms | 10ms | <5μs ⭐ |
| **硬件资源** | 1个ADC通道 | 8个IO | 4个中断+4个IO |
| **抗干扰性** | 高 | 中 | 高 |
| **适用场景** | 多按键 | 大量按键 | 关键按键 |

---

## 使用建议

### 何时使用外部中断按键

**推荐使用：**
- ✅ 需要快速响应的按键（如紧急停止）
- ✅ 按键数量≤4个
- ✅ 需要精确的按键时序
- ✅ 低功耗模式唤醒按键

**不推荐使用：**
- ❌ 按键数量>4个（IO资源不足）
- ❌ 按键容易误触（中断频繁触发）
- ❌ 不需要快速响应

### 与ADC按键/矩阵按键混合使用

**可以同时使用：**
```c
// Config.h
#define ENABLE_INT_KEY  1  // 外部中断按键（4个关键按键）

// Task.c
{0, 10,  10,  Sample_MatrixKey},  // 矩阵按键（16个普通按键）
{0, 10,  10,  Sample_adcKey},     // ADC按键（时间调整）
{0, 10,  10,  Sample_intKey},     // 外部中断按键（快速响应）
```

**优点：**
- 不同类型按键各司其职
- 外部中断按键用于关键功能
- 其他按键用于普通功能

---

## 故障排除

### 问题1：按键无响应

**检查清单：**
1. ✅ `ENABLE_INT_KEY = 1`
2. ✅ `intKey_init()` 已调用
3. ✅ 按键接线正确（接GND）
4. ✅ IO口配置正确
5. ✅ 中断已使能（EX0/EX1等）
6. ✅ 全局中断已使能（EA=1）

### 问题2：频繁误触发

**原因：**
- 按键抖动严重
- 外部干扰

**解决：**
```c
// 增加消抖时间
#define KEY_DEBOUNCE_TIME  50  // 从20ms增加到50ms
```

### 问题3：无法区分短按/长按

**原因：**
- 长按时间设置不合理

**解决：**
```c
// 调整长按时间
#define KEY_LONG_PRESS_TIME  300  // 从500ms减少到300ms
```

---

## 编译说明

### Keil uVision5配置

1. **添加源文件到项目：**
   ```
   Project → Add Files
   选择：Sources/src/app_intKey.c
   ```

2. **添加头文件路径：**
   ```
   已包含在项目配置中：Sources/inc
   ```

3. **编译选项：**
   ```
   - 在Config.h中设置ENABLE_INT_KEY
   - 重新编译整个项目
   ```

---

## 测试方法

### 功能测试

**测试1：短按功能**
```
操作：按下按键1，立即释放（<500ms）
预期：
  - 串口输出："Key1 Short Press"
  - intKeyEvent = 1
  - intKeyCode = 1
```

**测试2：长按功能**
```
操作：按下按键1，持续按住>500ms
预期：
  - 500ms时输出："Key1 Long Press START"
  - 然后每200ms输出："Key1 Long Press REPEAT"
  - intKeyEvent = 2（首次）或3（重复）
```

**测试3：多按键**
```
操作：快速按下按键1、2、3、4
预期：
  - 每个按键都能正确响应
  - 无按键丢失
  - 无误触发
```

---

## 进阶配置

### 修改按键功能

**编辑 `Sources/src/app_intKey.c` 的 `Sample_intKey()` 函数：**

```c
if(intKeyEvent == KEY_EVENT_SHORT)
{
    switch(intKeyCode)
    {
        case KEY_INT0:
            // TODO: 在这里添加按键1的功能
            break;
    }
}
```

### 禁用某个按键

```c
// 在intKey_init()中注释掉不需要的中断

void intKey_init(void)
{
    // ...
    
    // INT0配置
    IT0 = 1;
    EX0 = 1;  // 启用INT0
    
    // INT1配置
    // IT1 = 1;
    // EX1 = 1;  // 注释掉，禁用INT1
    
    // ...
}
```

---

## 与优化3的关联

### 中断优先级设置

当执行优化3时，会设置外部中断的优先级：

```c
// System_init.c - SYS_Init()
PT0 = 1;   // Timer0高优先级（任务调度）⭐
PX0 = 0;   // INT0低优先级（按键）
PX1 = 0;   // INT1低优先级（按键）
// INT2/3在IP2中设置，保持默认低优先级
```

**效果：**
- Timer0（任务调度）不会被按键中断打断
- 按键中断可能被Timer0延迟25μs
- 但25μs对按键响应完全无影响 ✅

---

## 性能分析

### 中断频率分析

**最坏情况：**
```
4个按键同时快速连按：
  - 中断频率：4个 × 10次/秒 = 40次/秒
  - 每次中断：<5μs
  - CPU占用：40 × 5μs = 200μs/秒 = 0.02%
  
结论：几乎不占用CPU ✅
```

### 与任务调度的协同

**任务配置：**
```c
{0, 10, 10, Sample_intKey},  // 每10ms执行
```

**执行流程：**
```
1. 按键按下 → INT中断触发（<5μs）
2. 设置按下标志 → 返回主程序
3. 10ms后任务执行 → 检测按键状态
4. 消抖20ms后确认 → 触发事件
5. 应用层处理事件 → 执行功能

总响应时间：<30ms ✅ 用户无感知
```

---

## 文件清单

### 新增文件

| 文件 | 路径 | 大小 | 说明 |
|------|------|------|------|
| `app_intKey.h` | Sources/inc/ | ~1.5KB | 头文件 |
| `app_intKey.c` | Sources/src/ | ~6KB | 实现文件 |
| `外部中断按键模块使用说明.md` | 项目根目录 | 本文件 | 使用文档 |

### 修改文件

| 文件 | 修改内容 | 说明 |
|------|---------|------|
| `Config.h` | 添加`ENABLE_INT_KEY`开关 | 可配置启用 |
| `app.h` | 引入`app_intKey.h` | 条件编译 |
| `Sources/src/app.c` | 添加`intKey_init()` | 初始化 |
| `Sources/src/Task.c` | 添加`Sample_intKey`任务 | 调度集成 |

---

## 常见问题

### Q1: 为什么不直接在中断中处理按键功能？

**A:** 中断应尽可能短，仅做标记
- 在中断中执行复杂逻辑会影响其他任务
- 当前设计：中断<5μs，功能在10ms任务中处理
- 平衡了响应速度和系统稳定性

### Q2: 能否增加更多按键？

**A:** AI8051U仅有4个外部中断
- INT0-3已全部使用
- 如需更多按键，使用ADC按键或矩阵按键
- 或使用IO中断（所有IO都支持中断）

### Q3: 如何调整长按时间？

**A:** 修改宏定义
```c
#define KEY_LONG_PRESS_TIME  300  // 300ms判定为长按
```

---

## 升级建议

### 可选增强功能

1. **双击检测**
   - 检测200ms内两次短按
   - 触发双击事件

2. **组合键**
   - 检测两个按键同时按下
   - 触发组合键事件

3. **可配置回调**
   - 允许用户注册回调函数
   - 类似任务钩子机制

4. **IO中断扩展**
   - 使用P0-P7的IO中断
   - 支持更多按键

---

## 总结

**模块特点：**
- ✅ 响应速度快（<30ms）
- ✅ CPU占用极低（<0.1%）
- ✅ 功能完整（短按/长按/重复）
- ✅ 可配置启用/禁用
- ✅ 易于集成和使用

**推荐用途：**
- 菜单导航按键
- 功能切换按键
- 紧急停止按键
- 模式选择按键

---

**创建完成！模块已集成到任务调度系统中。** ✅

