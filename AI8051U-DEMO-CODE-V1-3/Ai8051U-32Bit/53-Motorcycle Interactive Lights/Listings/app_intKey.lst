C251 COMPILER V5.60.0,  app_intKey                                                         10/11/25  23:53:23  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE app_intKey
OBJECT MODULE PLACED IN .\Objects\app_intKey.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE Sources\src\app_intKey.c XSMALL INTR2 BROWSE INCDIR(.\Sources\inc) DEB
                    -UG PRINT(.\Listings\app_intKey.lst) TABS(2) OBJECT(.\Objects\app_intKey.obj) 

stmt  level    source

    1          /*---------------------------------------------------------------------*/
    2          /* --- Web: www.STCAI.com ---------------------------------------------*/
    3          /*---------------------------------------------------------------------*/
    4          
    5          #include "config.h"
    6          #include "app_intKey.h"
    7          
    8          /*************** åŠŸèƒ½è¯´æ˜ ****************
    9          
   10          å¤–éƒ¨ä¸­æ–­æŒ‰é”®æ¨¡å— (INT0/INT1/INT2/INT3)
   11          
   12          æ”¯æŒåŠŸèƒ½:
   13          1. çŸ­æŒ‰æ£€æµ‹ï¼ˆæŒ‰ä¸‹å¹¶é‡Šæ”¾<500msï¼‰
   14          2. é•¿æŒ‰æ£€æµ‹ï¼ˆæŒ‰ä¸‹æŒç»­>500msï¼‰
   15          3. é•¿æŒ‰é‡å¤ï¼ˆé•¿æŒ‰1ç§’åï¼Œæ¯200msè§¦å‘ä¸€æ¬¡ï¼‰
   16          4. ç¡¬ä»¶æ¶ˆæŠ–ï¼ˆä¸‹é™æ²¿ä¸­æ–­ï¼‰
   17          5. è½¯ä»¶æ¶ˆæŠ–ï¼ˆ20msç¡®è®¤ï¼‰
   18          
   19          æŒ‰é”®æ¥çº¿:
   20            INT0 - P3.2 (æŒ‰é”®1) - GND
   21            INT1 - P3.3 (æŒ‰é”®2) - GND
   22            INT2 - P3.6 (æŒ‰é”®3) - GND
   23            INT3 - P3.7 (æŒ‰é”®4) - GND
   24            
   25          æ³¨æ„: æŒ‰é”®éœ€å¤–æ¥ä¸Šæ‹‰ç”µé˜»(10K)æˆ–ä½¿èƒ½IOå†…éƒ¨ä¸Šæ‹‰
   26          
   27          ******************************************/
   28          
   29          //========================================================================
   30          //                               å…¨å±€å˜é‡
   31          //========================================================================
   32          
   33          // å…¨å±€æ—¶é—´æˆ³ï¼ˆéœ€è¦åœ¨Timer0ä¸­æ–­ä¸­é€’å¢ï¼‰
   34          // æ³¨æ„ï¼šéœ€è¦åœ¨Timer_Isr.cä¸­å®šä¹‰å’Œé€’å¢
   35          volatile u32 system_tick_ms = 0;
   36          
   37          //========================================================================
   38          //                               æœ¬åœ°å˜é‡å£°æ˜
   39          //========================================================================
   40          
   41          // å…¼å®¹æ€§å˜é‡ï¼ˆä¿ç•™ï¼‰
   42          u8  intKeyCode = 0;      // æŒ‰é”®ç : 1-4å¯¹åº”INT0-INT3, 0è¡¨ç¤ºæ— æŒ‰é”®
   43          u8  intKeyEvent = 0;     // æŒ‰é”®äº‹ä»¶: 0=æ— , 1=çŸ­æŒ‰, 2=é•¿æŒ‰, 3=é‡å¤
   44          u8  intKeyState = 0;     // å½“å‰çŠ¶æ€: 0=ç©ºé—², 1=æŒ‰ä¸‹, 2=é•¿æŒ‰, 3=é‡Šæ”¾
   45          
   46          // å†…éƒ¨å˜é‡
   47          u8  Key_PressFlag = 0;   // æŒ‰é”®æŒ‰ä¸‹æ ‡å¿—ï¼ˆä¸­æ–­ä¸­è®¾ç½®ï¼‰
   48          u8  Key_Which = 0;       // å“ªä¸ªæŒ‰é”®è¢«æŒ‰ä¸‹ï¼ˆ1-4ï¼‰
   49          u16 Key_HoldTime = 0;    // æŒ‰é”®æŒç»­æ—¶é—´ï¼ˆmsï¼‰
   50          u8  Key_DebounceCount = 0; // æ¶ˆæŠ–è®¡æ•°å™¨
   51          
   52          // å›è°ƒå‡½æ•°æŒ‡é’ˆï¼ˆæ–¹æ¡ˆCï¼‰
   53          KeyEventCallback key_event_callback = NULL;
   54          
   55          //========================================================================
   56          //                               æœ¬åœ°å¸¸é‡å®šä¹‰
   57          //========================================================================
   58          
C251 COMPILER V5.60.0,  app_intKey                                                         10/11/25  23:53:23  PAGE 2   

   59          #define KEY_DEBOUNCE_TIME    20    // æ¶ˆæŠ–æ—¶é—´: 20ms
   60          #define KEY_LONG_PRESS_TIME  500   // é•¿æŒ‰åˆ¤å®šæ—¶é—´: 500ms
   61          #define KEY_REPEAT_TIME      200   // é•¿æŒ‰é‡å¤é—´éš”: 200ms
   62          
   63          //========================================================================
   64          //                               æœ¬åœ°å‡½æ•°å£°æ˜
   65          //========================================================================
   66          
   67          void Default_KeyEventHandler(KEY_EVENT *event);
   68          
   69          //========================================================================
   70          // å‡½æ•°: intKey_init
   71          // æè¿°: å¤–éƒ¨ä¸­æ–­æŒ‰é”®åˆå§‹åŒ–
   72          // å‚æ•°: None.
   73          // è¿”å›: None.
   74          // ç‰ˆæœ¬: V1.0, 2025-10-21
   75          //========================================================================
   76          void intKey_init(void)
   77          {
   78   1          // åˆå§‹åŒ–å˜é‡
   79   1          intKeyCode = 0;
   80   1          intKeyEvent = 0;
   81   1          intKeyState = KEY_STATE_IDLE;
   82   1          Key_PressFlag = 0;
   83   1          Key_Which = 0;
   84   1          Key_HoldTime = 0;
   85   1          Key_DebounceCount = 0;
   86   1          
   87   1          //========================================================================
   88   1          // é…ç½®å¤–éƒ¨ä¸­æ–­ï¼ˆINT0/INT1/INT2/INT3ï¼‰
   89   1          //========================================================================
   90   1          
   91   1          // ä½¿èƒ½IOå£å†…éƒ¨ä¸Šæ‹‰ç”µé˜»ï¼ˆæŒ‰é”®éœ€è¦ä¸Šæ‹‰ï¼‰
   92   1          // P3M1 &= ~0xCC; P3M0 &= ~0xCC;  // ç¡®ä¿P3.2,3,6,7ä¸ºå‡†åŒå‘å£æ¨¡å¼ï¼ˆå·²åœ¨GPIO_configé…ç½®ï
             -¼‰
   93   1          
   94   1          // INT0é…ç½®ï¼ˆP3.2ï¼‰
   95   1          IT0 = 1;   // INT0ä¸‹é™æ²¿è§¦å‘
   96   1          EX0 = 1;   // ä½¿èƒ½INT0ä¸­æ–­
   97   1          PX0 = 0;   // INT0ä¼˜å…ˆçº§0ï¼ˆä½ï¼Œç¨ååœ¨ä¼˜åŒ–3ä¸­é…ç½®ï¼‰
   98   1          
   99   1          // INT1é…ç½®ï¼ˆP3.3ï¼‰
  100   1          IT1 = 1;   // INT1ä¸‹é™æ²¿è§¦å‘
  101   1          EX1 = 1;   // ä½¿èƒ½INT1ä¸­æ–­
  102   1          PX1 = 0;   // INT1ä¼˜å…ˆçº§0ï¼ˆä½ï¼‰
  103   1          
  104   1          // INT2é…ç½®ï¼ˆP3.6ï¼‰
  105   1          INTCLKO &= ~0x10;  // INT2ä¸‹é™æ²¿è§¦å‘
  106   1          INTCLKO |= 0x04;   // ä½¿èƒ½INT2ä¸­æ–­
  107   1          // INT2ä¼˜å…ˆçº§åœ¨IP2ä¸­è®¾ç½®ï¼Œä¿æŒé»˜è®¤
  108   1          
  109   1          // INT3é…ç½®ï¼ˆP3.7ï¼‰
  110   1          INTCLKO &= ~0x20;  // INT3ä¸‹é™æ²¿è§¦å‘
  111   1          INTCLKO |= 0x08;   // ä½¿èƒ½INT3ä¸­æ–­
  112   1          // INT3ä¼˜å…ˆçº§åœ¨IP2ä¸­è®¾ç½®ï¼Œä¿æŒé»˜è®¤
  113   1      }
  114          
  115          //========================================================================
  116          // å‡½æ•°: INT0_ISR_Handler
  117          // æè¿°: INT0å¤–éƒ¨ä¸­æ–­æœåŠ¡ç¨‹åº
  118          // å‚æ•°: none.
  119          // è¿”å›: none.
  120          // ç‰ˆæœ¬: V1.0, 2025-10-21
  121          //========================================================================
  122          void INT0_ISR_Handler(void) interrupt INT0_VECTOR
  123          {
C251 COMPILER V5.60.0,  app_intKey                                                         10/11/25  23:53:23  PAGE 3   

  124   1          // ä¸‹é™æ²¿è§¦å‘ï¼ŒæŒ‰é”®æŒ‰ä¸‹
  125   1          if(Key_PressFlag == 0)  // é¿å…é‡å¤è§¦å‘
  126   1          {
  127   2              Key_PressFlag = 1;
  128   2              Key_Which = KEY_INT0;
  129   2              Key_HoldTime = 0;
  130   2              Key_DebounceCount = 0;
  131   2          }
  132   1      }
  133          
  134          //========================================================================
  135          // å‡½æ•°: INT1_ISR_Handler
  136          // æè¿°: INT1å¤–éƒ¨ä¸­æ–­æœåŠ¡ç¨‹åº
  137          //========================================================================
  138          void INT1_ISR_Handler(void) interrupt INT1_VECTOR
  139          {
  140   1          if(Key_PressFlag == 0)
  141   1          {
  142   2              Key_PressFlag = 1;
  143   2              Key_Which = KEY_INT1;
  144   2              Key_HoldTime = 0;
  145   2              Key_DebounceCount = 0;
  146   2          }
  147   1      }
  148          
  149          //========================================================================
  150          // å‡½æ•°: INT2_ISR_Handler
  151          // æè¿°: INT2å¤–éƒ¨ä¸­æ–­æœåŠ¡ç¨‹åº
  152          //========================================================================
  153          void INT2_ISR_Handler(void) interrupt INT2_VECTOR
  154          {
  155   1          if(Key_PressFlag == 0)
  156   1          {
  157   2              Key_PressFlag = 1;
  158   2              Key_Which = KEY_INT2;
  159   2              Key_HoldTime = 0;
  160   2              Key_DebounceCount = 0;
  161   2          }
  162   1      }
  163          
  164          //========================================================================
  165          // å‡½æ•°: INT3_ISR_Handler
  166          // æè¿°: INT3å¤–éƒ¨ä¸­æ–­æœåŠ¡ç¨‹åº
  167          //========================================================================
  168          void INT3_ISR_Handler(void) interrupt INT3_VECTOR
  169          {
  170   1          if(Key_PressFlag == 0)
  171   1          {
  172   2              Key_PressFlag = 1;
  173   2              Key_Which = KEY_INT3;
  174   2              Key_HoldTime = 0;
  175   2              Key_DebounceCount = 0;
  176   2          }
  177   1      }
  178          
  179          //========================================================================
  180          // å‡½æ•°: Sample_intKey
  181          // æè¿°: å¤–éƒ¨ä¸­æ–­æŒ‰é”®å¤„ç†ä»»åŠ¡ï¼ˆæ¯10msæ‰§è¡Œä¸€æ¬¡ï¼‰
  182          // å‚æ•°: None.
  183          // è¿”å›: None.
  184          // ç‰ˆæœ¬: V1.0, 2025-10-21
  185          //========================================================================
  186          void Sample_intKey(void)
  187          {
  188   1          u8 key_pin_state = 1;  // é»˜è®¤é«˜ç”µå¹³ï¼ˆæœªæŒ‰ä¸‹çŠ¶æ€ï¼‰
  189   1          
C251 COMPILER V5.60.0,  app_intKey                                                         10/11/25  23:53:23  PAGE 4   

  190   1          // æ¸…é™¤ä¸Šæ¬¡çš„äº‹ä»¶
  191   1          intKeyEvent = KEY_EVENT_NONE;
  192   1          
  193   1          // å¦‚æœæœ‰æŒ‰é”®æŒ‰ä¸‹æ ‡å¿—
  194   1          if(Key_PressFlag)
  195   1          {
  196   2              // è¯»å–æŒ‰é”®å½“å‰çŠ¶æ€ï¼ˆæ£€æµ‹æ˜¯å¦ä»æŒ‰ä¸‹ï¼‰
  197   2              switch(Key_Which)
  198   2              {
  199   3                  case KEY_INT0: key_pin_state = P32; break;
  200   3                  case KEY_INT1: key_pin_state = P33; break;
  201   3                  case KEY_INT2: key_pin_state = P36; break;
  202   3                  case KEY_INT3: key_pin_state = P37; break;
  203   3                  default: key_pin_state = 1; break;
  204   3              }
  205   2              
  206   2              // æŒ‰é”®ä»ç„¶æŒ‰ä¸‹ï¼ˆä½ç”µå¹³ï¼‰
  207   2              if(key_pin_state == 0)
  208   2              {
  209   3                  // æ¶ˆæŠ–å¤„ç†ï¼ˆéœ€è¦è¿ç»­20msç¡®è®¤ï¼‰
  210   3                  if(Key_DebounceCount < (KEY_DEBOUNCE_TIME / 10))
  211   3                  {
  212   4                      Key_DebounceCount++;
  213   4                      return;  // æ¶ˆæŠ–æœŸé—´ï¼Œä¸å¤„ç†
  214   4                  }
  215   3                  
  216   3                  // æ¶ˆæŠ–å®Œæˆï¼Œç¡®è®¤æŒ‰é”®æœ‰æ•ˆ
  217   3                  if(intKeyState == KEY_STATE_IDLE)
  218   3                  {
  219   4                      // ç¬¬ä¸€æ¬¡ç¡®è®¤æŒ‰ä¸‹
  220   4                      intKeyState = KEY_STATE_PRESS;
  221   4                      intKeyCode = Key_Which;
  222   4                      Key_HoldTime = 0;
  223   4                  }
  224   3                  else if(intKeyState == KEY_STATE_PRESS)
  225   3                  {
  226   4                      // æŒ‰é”®æŒç»­æŒ‰ä¸‹ï¼Œç´¯è®¡æ—¶é—´
  227   4                      Key_HoldTime += 10;  // æ¯10msç´¯åŠ 
  228   4                      
  229   4                      // æ£€æµ‹æ˜¯å¦è¾¾åˆ°é•¿æŒ‰æ—¶é—´
  230   4                      if(Key_HoldTime >= KEY_LONG_PRESS_TIME)
  231   4                      {
  232   5                          intKeyState = KEY_STATE_HOLD;
  233   5                          intKeyEvent = KEY_EVENT_LONG;  // è§¦å‘é•¿æŒ‰äº‹ä»¶
  234   5                          Key_HoldTime = 0;  // é‡ç½®ï¼Œç”¨äºé‡å¤è®¡æ—¶
  235   5                      }
  236   4                  }
  237   3                  else if(intKeyState == KEY_STATE_HOLD)
  238   3                  {
  239   4                      // é•¿æŒ‰çŠ¶æ€ï¼Œæ£€æµ‹é‡å¤è§¦å‘
  240   4                      Key_HoldTime += 10;
  241   4                      
  242   4                      if(Key_HoldTime >= KEY_REPEAT_TIME)
  243   4                      {
  244   5                          intKeyEvent = KEY_EVENT_REPEAT;  // è§¦å‘é‡å¤äº‹ä»¶
  245   5                          Key_HoldTime = 0;  // é‡ç½®ï¼Œç»§ç»­é‡å¤
  246   5                      }
  247   4                  }
  248   3              }
  249   2              else  // æŒ‰é”®å·²é‡Šæ”¾ï¼ˆé«˜ç”µå¹³ï¼‰
  250   2              {
  251   3                  // æŒ‰é”®é‡Šæ”¾å¤„ç†
  252   3                  if(intKeyState == KEY_STATE_PRESS)
  253   3                  {
  254   4                      // çŸ­æŒ‰ï¼šæŒ‰ä¸‹æ—¶é—´<500ms
  255   4                      intKeyEvent = KEY_EVENT_SHORT;
C251 COMPILER V5.60.0,  app_intKey                                                         10/11/25  23:53:23  PAGE 5   

  256   4                      intKeyCode = Key_Which;
  257   4                  }
  258   3                  
  259   3                  // æ¸…é™¤çŠ¶æ€
  260   3                  intKeyState = KEY_STATE_IDLE;
  261   3                  Key_PressFlag = 0;
  262   3                  Key_Which = 0;
  263   3                  Key_HoldTime = 0;
  264   3                  Key_DebounceCount = 0;
  265   3              }
  266   2          }
  267   1          
  268   1          //========================================================================
  269   1          // æ–¹æ¡ˆCï¼šäº‹ä»¶ç»“æ„ä½“å›è°ƒæœºåˆ¶
  270   1          //========================================================================
  271   1          if(intKeyEvent != KEY_EVENT_NONE)
  272   1          {
  273   2              // æ„å»ºäº‹ä»¶ç»“æ„ä½“
  274   2              KEY_EVENT event;
  275   2              event.key_num = intKeyCode;
  276   2              event.event_type = intKeyEvent;
  277   2              event.hold_time = Key_HoldTime;
  278   2              event.pin_state = key_pin_state;
  279   2              event.timestamp = system_tick_ms;
  280   2              
  281   2              // è°ƒç”¨ç”¨æˆ·æ³¨å†Œçš„å›è°ƒå‡½æ•°
  282   2              if(key_event_callback != NULL)
  283   2              {
  284   3                  key_event_callback(&event);  // è§¦å‘å›è°ƒ
  285   3              }
  286   2              else
  287   2              {
  288   3                  // å¦‚æœæœªæ³¨å†Œå›è°ƒï¼Œä½¿ç”¨é»˜è®¤å¤„ç†ï¼ˆå…¼å®¹æ¨¡å¼ï¼‰
  289   3                  Default_KeyEventHandler(&event);
  290   3              }
  291   2              
  292   2              // æ¸…é™¤æŒ‰é”®ç å’Œäº‹ä»¶
  293   2              intKeyCode = 0;
  294   2              intKeyEvent = KEY_EVENT_NONE;
  295   2          }
  296   1      }
  297          
  298          //========================================================================
  299          // å‡½æ•°: Default_KeyEventHandler
  300          // æè¿°: é»˜è®¤æŒ‰é”®äº‹ä»¶å¤„ç†å‡½æ•°ï¼ˆç¤ºä¾‹ï¼‰
  301          // å‚æ•°: event - äº‹ä»¶ä¿¡æ¯æŒ‡é’ˆ
  302          // è¿”å›: None.
  303          // ç‰ˆæœ¬: V1.0, 2025-10-21
  304          //========================================================================
  305          void Default_KeyEventHandler(KEY_EVENT *event)
  306          {
  307   1          //========================================================================
  308   1          // é»˜è®¤å¤„ç†ç¤ºä¾‹ï¼ˆæœªæ³¨å†Œå›è°ƒæ—¶ä½¿ç”¨ï¼‰
  309   1          // ç”¨æˆ·å¯ä»¥ä¿®æ”¹æ­¤å‡½æ•°ï¼Œæˆ–æ³¨å†Œè‡ªå·±çš„å›è°ƒå‡½æ•°
  310   1          //========================================================================
  311   1          
  312   1          if(event->event_type == KEY_EVENT_SHORT)
  313   1          {
  314   2              // çŸ­æŒ‰äº‹ä»¶
  315   2              printf("[Default] Key%d Short Press (held %dms)\r\n", 
  316   2                     event->key_num, event->hold_time);
  317   2              
  318   2              switch(event->key_num)
  319   2              {
  320   3                  case KEY_INT0:  // æŒ‰é”®1çŸ­æŒ‰
  321   3                      printf("  -> Key1 function\r\n");
C251 COMPILER V5.60.0,  app_intKey                                                         10/11/25  23:53:23  PAGE 6   

  322   3                      // TODO: æ·»åŠ æ‚¨çš„åŠŸèƒ½
  323   3                      break;
  324   3                      
  325   3                  case KEY_INT1:  // æŒ‰é”®2çŸ­æŒ‰
  326   3                      printf("  -> Key2 function\r\n");
  327   3                      break;
  328   3                      
  329   3                  case KEY_INT2:  // æŒ‰é”®3çŸ­æŒ‰
  330   3                      printf("  -> Key3 function\r\n");
  331   3                      break;
  332   3                      
  333   3                  case KEY_INT3:  // æŒ‰é”®4çŸ­æŒ‰
  334   3                      printf("  -> Key4 function\r\n");
  335   3                      break;
  336   3              }
  337   2          }
  338   1          else if(event->event_type == KEY_EVENT_LONG)
  339   1          {
  340   2              // é•¿æŒ‰äº‹ä»¶ï¼ˆé¦–æ¬¡è§¦å‘ï¼‰
  341   2              printf("[Default] Key%d Long Press START\r\n", event->key_num);
  342   2              
  343   2              // TODO: æ·»åŠ é•¿æŒ‰åŠŸèƒ½
  344   2          }
  345   1          else if(event->event_type == KEY_EVENT_REPEAT)
  346   1          {
  347   2              // é•¿æŒ‰é‡å¤äº‹ä»¶
  348   2              printf("[Default] Key%d REPEAT (held %dms)\r\n", 
  349   2                     event->key_num, event->hold_time);
  350   2              
  351   2              // TODO: æ·»åŠ é‡å¤åŠŸèƒ½
  352   2          }
  353   1      }
  354          
  355          //========================================================================
  356          // å‡½æ•°: intKey_RegisterCallback
  357          // æè¿°: æ³¨å†ŒæŒ‰é”®äº‹ä»¶å›è°ƒå‡½æ•°
  358          // å‚æ•°: callback - å›è°ƒå‡½æ•°æŒ‡é’ˆ
  359          // è¿”å›: None.
  360          // ç‰ˆæœ¬: V1.0, 2025-10-21
  361          //========================================================================
  362          void intKey_RegisterCallback(KeyEventCallback callback)
  363          {
  364   1          key_event_callback = callback;
  365   1          
  366   1          if(callback != NULL)
  367   1          {
  368   2              printf("Key callback registered\r\n");
  369   2          }
  370   1          else
  371   1          {
  372   2              printf("Key callback unregistered, using default handler\r\n");
  373   2          }
  374   1      }
  375          
  376          //========================================================================
  377          // å‡½æ•°: intKey_GetEventName
  378          // æè¿°: è·å–äº‹ä»¶ç±»å‹åç§°ï¼ˆè¾…åŠ©å‡½æ•°ï¼‰
  379          // å‚æ•°: event_type - äº‹ä»¶ç±»å‹
  380          // è¿”å›: äº‹ä»¶åç§°å­—ç¬¦ä¸²
  381          // ç‰ˆæœ¬: V1.0, 2025-10-21
  382          //========================================================================
  383          const char* intKey_GetEventName(u8 event_type)
  384          {
  385   1          switch(event_type)
  386   1          {
  387   2              case KEY_EVENT_NONE:   return "NONE";
C251 COMPILER V5.60.0,  app_intKey                                                         10/11/25  23:53:23  PAGE 7   

  388   2              case KEY_EVENT_SHORT:  return "SHORT";
  389   2              case KEY_EVENT_LONG:   return "LONG";
  390   2              case KEY_EVENT_REPEAT: return "REPEAT";
  391   2              default:               return "UNKNOWN";
  392   2          }
  393   1      }
  394          
  395          //========================================================================
  396          // å‡½æ•°: intKey_GetKeyName
  397          // æè¿°: è·å–æŒ‰é”®åç§°ï¼ˆè¾…åŠ©å‡½æ•°ï¼‰
  398          // å‚æ•°: key_num - æŒ‰é”®ç¼–å·
  399          // è¿”å›: æŒ‰é”®åç§°å­—ç¬¦ä¸²
  400          // ç‰ˆæœ¬: V1.0, 2025-10-21
  401          //========================================================================
  402          const char* intKey_GetKeyName(u8 key_num)
  403          {
  404   1          switch(key_num)
  405   1          {
  406   2              case KEY_INT0: return "KEY1(INT0)";
  407   2              case KEY_INT1: return "KEY2(INT1)";
  408   2              case KEY_INT2: return "KEY3(INT2)";
  409   2              case KEY_INT3: return "KEY4(INT3)";
  410   2              default:       return "UNKNOWN";
  411   2          }
  412   1      }
  413          


Module Information          Static   Overlayable
------------------------------------------------
  code size            =       839     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =        14          9
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =       400     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
