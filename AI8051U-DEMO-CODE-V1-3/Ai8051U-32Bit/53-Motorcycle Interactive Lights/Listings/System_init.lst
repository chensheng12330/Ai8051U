C251 COMPILER V5.60.0,  System_init                                                        10/11/25  23:52:58  PAGE 1   


C251 COMPILER V5.60.0, COMPILATION OF MODULE System_init
OBJECT MODULE PLACED IN .\Objects\System_init.obj
COMPILER INVOKED BY: C:\Keil_v5\C251\BIN\C251.EXE Sources\src\System_init.c XSMALL INTR2 BROWSE INCDIR(.\Sources\inc) DE
                    -BUG PRINT(.\Listings\System_init.lst) TABS(2) OBJECT(.\Objects\System_init.obj) 

stmt  level    source

    1          /*---------------------------------------------------------------------*/
    2          /* --- Web: www.STCAI.com ---------------------------------------------*/
    3          /*---------------------------------------------------------------------*/
    4          
    5          #include "config.h"
    6          #include "app.h"
    7          
    8          //========================================================================
    9          //                                IO口配置
   10          //========================================================================
   11          void GPIO_config(void)
   12          {
   13   1          // P0: 全部输入 (原车信号、传感器、音频、电压)
   14   1          P0M1 = 0x00;   P0M0 = 0x00;   //准双向口 (输入)
   15   1      
   16   1          // P1: 混合配置
   17   1          // P1.0, P1.5: PWM输出 (刹车灯、蜂鸣器)
   18   1          // P1.1-P1.3: PWM输出 (RGB灯组)
   19   1          // P1.6-P1.7: 推挽输出 (状态LED)
   20   1          P1M1 = 0x00;   P1M0 = 0xC3;   // P1.0,P1.1,P1.5,P1.6,P1.7推挽输出
   21   1      
   22   1          // P2: P2.5 SPI输出 (WS2812)
   23   1          P2M1 = 0x00;   P2M0 = 0x20;   // P2.5推挽输出
   24   1      
   25   1          // P3: 准双向口 (按键输入)
   26   1          P3M1 = 0x00;   P3M0 = 0x00;   //准双向口
   27   1      
   28   1          // P4: 混合配置
   29   1          // P4.6: 输入 (掉电检测)
   30   1          // P4.7: 输入 (复位按键)
   31   1          P4M1 = 0x00;   P4M0 = 0x00;   //准双向口
   32   1      
   33   1          // P5: UART4调试
   34   1          P5M1 = 0x00;   P5M0 = 0x0C;   // P5.2,P5.3推挽输出 (UART4)
   35   1      
   36   1          // P6-P7: 准双向口 (保留)
   37   1          P6M1 = 0x00;   P6M0 = 0x00;
   38   1          P7M1 = 0x00;   P7M0 = 0x00;
   39   1      
   40   1          // NTC供电 (保持原有功能)
   41   1          P51 = 1;
   42   1      }
   43          
   44          //========================================================================
   45          //                               定时器配置
   46          //========================================================================
   47          void Timer_config(void)
   48          {
   49   1          AUXR = 0x80;    //Timer0 set as 1T, 16 bits timer auto-reload, 
   50   1          TH0 = (u8)(Timer0_Reload / 256);
   51   1          TL0 = (u8)(Timer0_Reload % 256);
   52   1          ET0 = 1;        //Timer0 interrupt enable
   53   1          TR0 = 1;        //Tiner0 run
   54   1      }
   55          
   56          //========================================================================
   57          //                              ADC初始化
   58          //========================================================================
C251 COMPILER V5.60.0,  System_init                                                        10/11/25  23:52:58  PAGE 2   

   59          void ADC_config(void)
   60          {
   61   1          ADCTIM = 0x3f;      //设置 ADC 内部时序，ADC采样时间建议设最大值
   62   1          ADCCFG = 0x2f;      //设置 ADC 时钟为系统时钟/2/16/16
   63   1          ADC_CONTR = 0x80;   //使能 ADC 模块
   64   1      }
   65          
   66          //========================================================================
   67          //                              PWM初始化
   68          //========================================================================
   69          void PWM_config(void)
   70          {
   71   1          PWMB_CCER1 = 0x00;  //写 CCMRx 前必须先清零 CCxE 关闭通道
   72   1          PWMB_CCMR1 = 0x30;  //通道模式配置，翻转模式
   73   1          PWMB_CCER1 = 0x01;  //配置通道输出使能和极性
   74   1      
   75   1          PWMB_ARRH = 0x07;   //设置周期时间
   76   1          PWMB_ARRL = 0xff;
   77   1      
   78   1          PWMB_ENO = 0x00;    //PWM5关闭输出
   79   1      //    PWMB_ENO = 0x01;    //PWM5使能输出
   80   1          PWMB_PS = 0x03;     //高级 PWM 通道输出脚选择位, P50
   81   1      
   82   1          PWMB_BKR = 0x80;    //使能主输出
   83   1          PWMB_CR1 |= 0x01;   //开始计时
   84   1      }
   85          
   86          //========================================================================
   87          //                              UART初始化
   88          //========================================================================
   89          void UartInit(void)
   90          {
   91   1      #if(PrintUart == 1)
   92   1          S1_S1 = 0;      //UART1 switch to, 00: P3.0 P3.1, 01: P3.6 P3.7, 10: P1.6 P1.7, 11: P4.3 P4.4
   93   1          S1_S0 = 0;
   94   1          SCON = (SCON & 0x3f) | 0x40;
   95   1          T1x12 = 1;      //定时器时钟1T模式
   96   1          S1BRT = 0;      //串口1选择定时器1为波特率发生器
   97   1          TL1  = TM;
   98   1          TH1  = TM>>8;
   99   1          TR1 = 1;        //定时器1开始计时
  100   1      
  101   1      //    SCON = (SCON & 0x3f) | 0x40; 
  102   1      //    T2L  = TM;
  103   1      //    T2H  = TM>>8;
  104   1      //    AUXR |= 0x15;   //串口1选择定时器2为波特率发生器
  105   1      #else
                   S2_S = 1;       //UART2 switch to: 0: P1.2 P1.3,  1: P4.2 P4.3
                   S2CFG |= 0x01;  //使用串口2时，W1位必需设置为1，否则可能会产生不可预期的错
             -
                   S2CON = (SCON & 0x3f) | 0x40; 
                   T2L  = TM;
                   T2H  = TM>>8;
                   AUXR |= 0x14;   //定时器2时钟1T模式,开始计时
               #endif
  113   1      }
  114          
  115          void UartPutc(unsigned char dat)
  116          {
  117   1      #if(PrintUart == 1)
  118   1          SBUF = dat; 
  119   1          while(TI == 0);
  120   1          TI = 0;
  121   1      #else
                   S2BUF  = dat; 
                   while(S2TI == 0);
C251 COMPILER V5.60.0,  System_init                                                        10/11/25  23:52:58  PAGE 3   

                   S2TI = 0;    //Clear Tx flag
               #endif
  126   1      }
  127          
  128          char putchar(char c)
  129          {
  130   1          UartPutc(c);
  131   1          return c;
  132   1      }
  133          
  134          //========================================================================
  135          //                                系统初始化
  136          //========================================================================
  137          void SYS_Init(void)
  138          {
  139   1          GPIO_config();
  140   1          Timer_config();
  141   1          ADC_config();
  142   1          PWM_config();
  143   1          UartInit();
  144   1          
  145   1          //========================================================================
  146   1          // 优化3：设置中断优先级（保护任务调度中断）
  147   1          //========================================================================
  148   1          // AI8051U支持4级中断优先级（IPH, IP组合）：
  149   1          //   优先级3（最高）: IPH=1, IP=1
  150   1          //   优先级2:         IPH=1, IP=0
  151   1          //   优先级1:         IPH=0, IP=1
  152   1          //   优先级0（最低）: IPH=0, IP=0（默认）
  153   1          //
  154   1          // 优先级规划：
  155   1          //   - Timer0（任务调度）: 优先级1（高）⭐ 最关键
  156   1          //   - INT0-1（原有按键）: 优先级0（低，默认）
  157   1          //   - INT2-3（新按键）:   优先级0（低，默认）
  158   1          //   - Timer1（波特率）:   优先级0（低，无中断）
  159   1          //   - UART（串口）:       优先级0（低，轮询方式）
  160   1          //
  161   1          // 效果：
  162   1          //   - Timer0永不被其他中断打断，保证任务调度时序精确
  163   1          //   - 即使将来添加新中断，也不会影响任务调度
  164   1          //   - 与EA=0形成双重保护机制
  165   1          //========================================================================
  166   1      
  167   1          PT0 = 1;  // Timer0中断优先级 = 1（高于默认的0）⭐ 关键设置
  168   1          PT1 = 0;  // Timer1保持默认优先级0（实际不使用中断）
  169   1          PS  = 0;  // 串口保持默认优先级0（实际不使用中断）
  170   1      
  171   1      #if ENABLE_INT_KEY
  172   1          // 外部中断按键优先级设置为0（低），不影响任务调度
  173   1          PX0 = 0;  // INT0优先级0（低）
  174   1          PX1 = 0;  // INT1优先级0（低）
  175   1      #endif
  176   1      
  177   1          // INT2/INT3 中断配置 (摩托车灯组系统按键)
  178   1          //PX2 = 0;  // INT2优先级0（低）- 测试按键
  179   1          //PX3 = 0;  // INT3优先级0（低）- 菜单按键
  180   1          
  181   1          // 注意：其他未使用的中断保持默认优先级0
  182   1          //========================================================================
  183   1          
  184   1          EA = 1;
  185   1      
  186   1          APP_config();
  187   1      }


C251 COMPILER V5.60.0,  System_init                                                        10/11/25  23:52:58  PAGE 4   

Module Information          Static   Overlayable
------------------------------------------------
  code size            =       255     ------
  ecode size           =    ------     ------
  data size            =    ------     ------
  idata size           =    ------     ------
  pdata size           =    ------     ------
  xdata size           =    ------     ------
  xdata-const size     =    ------     ------
  edata size           =    ------     ------
  bit size             =    ------     ------
  ebit size            =    ------     ------
  bitaddressable size  =    ------     ------
  ebitaddressable size =    ------     ------
  far data size        =    ------     ------
  huge data size       =    ------     ------
  const size           =    ------     ------
  hconst size          =    ------     ------
End of Module Information.


C251 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
