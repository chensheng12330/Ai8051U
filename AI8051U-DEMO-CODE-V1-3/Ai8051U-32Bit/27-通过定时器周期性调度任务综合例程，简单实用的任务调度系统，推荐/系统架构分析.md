# AI8051U 任务调度系统 - 深度技术分析

> **📊 可视化图表：** 本文档配有完整的 Draw.io 可编辑图表，位于 `图表/` 目录：
> - `1-主程序执行流程图.drawio` - 可在 https://app.diagrams.net 中打开编辑
> - `2-任务调度时序图.drawio`
> - `3-中断与主循环交互序列图.drawio`
> - `4-系统分层架构图.drawio`
> 
> **使用说明请参阅：** `图表/README.md`

---

## 一、系统流程图

> **💡 提示：** 以下文本流程图已转换为专业的 Draw.io 格式，可在 `图表/1-主程序执行流程图.drawio` 中查看和编辑。

### 1.1 主程序执行流程

```
┌─────────────────────────────────────────────────────────────┐
│                        系统启动                              │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                    硬件初始化                                │
│  • WTST = 0          (CPU最高速度)                          │
│  • EAXFR = 1         (扩展寄存器使能)                        │
│  • CKCON = 0         (高速访问XRAM)                          │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                    SYS_Init()                               │
│  ┌──────────────────────────────────────────────┐          │
│  │ GPIO_config()      配置IO口模式               │          │
│  │ Timer_config()     配置Timer0 (1ms中断)      │          │
│  │ ADC_config()       配置ADC模块                │          │
│  │ PWM_config()       配置PWM (蜂鸣器)           │          │
│  │ UartInit()         配置串口调试               │          │
│  │ EA = 1             使能全局中断               │          │
│  │ APP_config()       应用层初始化               │          │
│  │  ├─ Display_init() 清空显示缓冲              │          │
│  │  ├─ RTC_init()     时钟初始化                 │          │
│  │  └─ adcKey_init()  按键状态初始化             │          │
│  └──────────────────────────────────────────────┘          │
└────────────────────────┬────────────────────────────────────┘
                         │
                         ▼
┌─────────────────────────────────────────────────────────────┐
│                    主循环 while(1)                           │
│  ┌──────────────────────────────────────────────┐          │
│  │                                               │          │
│  │    Task_Pro_Handler_Callback()               │          │
│  │         │                                     │          │
│  │         ├─ 扫描所有任务                       │          │
│  │         ├─ 检查 Run 标志                      │          │
│  │         ├─ 执行就绪任务                       │          │
│  │         └─ 清除 Run 标志                      │          │
│  │                                               │          │
│  └──────────────────────────────────────────────┘          │
│                         │                                    │
│                         └───────┐                           │
│                                 │ (无限循环)                │
└─────────────────────────────────┴───────────────────────────┘
                         ▲
                         │
                    中断驱动
                         │
┌────────────────────────┴────────────────────────────────────┐
│              Timer0 中断服务程序 (1ms)                       │
│  ┌──────────────────────────────────────────────┐          │
│  │                                               │          │
│  │    Task_Marks_Handler_Callback()             │          │
│  │         │                                     │          │
│  │         ├─ for (所有任务)                     │          │
│  │         ├─ TIMCount--                         │          │
│  │         ├─ if (TIMCount == 0)                │          │
│  │         │    ├─ TIMCount = TRITime (重载)    │          │
│  │         │    └─ Run = 1 (标记就绪)           │          │
│  │         └─ 返回主程序                         │          │
│  │                                               │          │
│  └──────────────────────────────────────────────┘          │
│                                                              │
│  执行时间: < 50μs                                           │
└─────────────────────────────────────────────────────────────┘
```

---

## 二、任务调度时序图

> **💡 提示：** 以下时序图已转换为专业的 Draw.io 格式，可在 `图表/2-任务调度时序图.drawio` 中查看和编辑。

### 2.1 多任务调度时序

```
时间轴 (ms)
0    1    2    3    4    5    6    7    8    9    10   11   12   ...  300  ...  500
│    │    │    │    │    │    │    │    │    │    │    │    │         │         │
Timer0中断 (1ms周期)
├────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────┼────...─┼────...─┼────
│    │    │    │    │    │    │    │    │    │    │    │    │         │         │
▼    ▼    ▼    ▼    ▼    ▼    ▼    ▼    ▼    ▼    ▼    ▼    ▼         ▼         ▼
标记 标记 标记 标记 标记 标记 标记 标记 标记 标记 标记 标记 标记      标记      标记

任务1: Sample_Display (1ms周期)
█────█────█────█────█────█────█────█────█────█────█────█────█─────...█────...─█────
    执行  执行  执行  执行  执行  执行  执行  执行  执行  执行  执行  执行      执行      执行

任务2: Sample_MatrixKey (10ms周期)
         █────────────────────────────────────█────────────────────...█────────
              执行                                执行                    执行

任务3: Sample_adcKey (10ms周期)
         █────────────────────────────────────█────────────────────...█────────
              执行                                执行                    执行

任务4: Sample_NTC (300ms周期)
                                                                       █────────
                                                                            执行

任务5: Sample_RTC (500ms周期)
                                                                                █─
                                                                                 执行

主循环执行顺序 (每次循环):
1. 检查任务1 → 执行
2. 检查任务2 → 执行/跳过
3. 检查任务3 → 执行/跳过
4. 检查任务4 → 执行/跳过
5. 检查任务5 → 执行/跳过
```

### 2.2 中断与主循环交互时序

> **💡 提示：** 以下序列图已转换为专业的 Draw.io 格式，可在 `图表/3-中断与主循环交互序列图.drawio` 中查看和编辑。

```
Timer0中断                主循环
   │                       │
   │ 1ms到                │
   ├──────────────────────>│ (中断主循环)
   │                       │
   │ Task_Marks_Handler    │
   │  ├─ Task1.TIMCount--  │
   │  │   = 0 → Run=1      │
   │  ├─ Task2.TIMCount--  │
   │  │   = 9               │
   │  ├─ Task3.TIMCount--  │
   │  │   = 9               │
   │  ├─ Task4.TIMCount--  │
   │  │   = 299             │
   │  └─ Task5.TIMCount--  │
   │      = 499             │
   │                       │
   │ 返回主循环 (50μs)     │
   │<──────────────────────┤
   │                       │
   │                       │ Task_Pro_Handler
   │                       │  ├─ Task1.Run==1
   │                       │  │   执行 Sample_Display()
   │                       │  │   (约200μs)
   │                       │  ├─ Task2.Run==0 (跳过)
   │                       │  ├─ Task3.Run==0 (跳过)
   │                       │  ├─ Task4.Run==0 (跳过)
   │                       │  └─ Task5.Run==0 (跳过)
   │                       │
   │ 下一次1ms中断         │ 继续循环...
   ├──────────────────────>│
```

---

## 三、功能架构图

> **💡 提示：** 以下架构图已转换为专业的 Draw.io 格式，可在 `图表/4-系统分层架构图.drawio` 中查看和编辑。

### 3.1 系统分层架构

```
┌────────────────────────────────────────────────────────────────┐
│                         应用层 (Application Layer)              │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌───────────────┐  ┌───────────────┐  ┌───────────────┐     │
│  │ Sample_Display│  │Sample_Matrix  │  │ Sample_adcKey │     │
│  │   (1ms)       │  │   Key (10ms)  │  │   (10ms)      │     │
│  │               │  │               │  │               │     │
│  │ 8位LED扫描    │  │ 4x4矩阵键盘   │  │ ADC按键扫描   │     │
│  │ 通过HC595     │  │ 消抖+识别     │  │ 时间调整      │     │
│  └───────────────┘  └───────────────┘  └───────────────┘     │
│                                                                 │
│  ┌───────────────┐  ┌───────────────┐                         │
│  │  Sample_NTC   │  │  Sample_RTC   │                         │
│  │   (300ms)     │  │   (500ms)     │                         │
│  │               │  │               │                         │
│  │ NTC温度采集   │  │ 软件RTC时钟   │                         │
│  │ 12位ADC+查表  │  │ 时分秒计时    │                         │
│  └───────────────┘  └───────────────┘                         │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────┐
│                    任务调度层 (Scheduler Layer)                 │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────────────────────────────────────────────────┐  │
│  │            任务控制块数组 (Task_Comps[])                 │  │
│  ├─────────────────────────────────────────────────────────┤  │
│  │ Task[0]: Run=?, TIMCount=1,   TRITime=1,   Hook=...     │  │
│  │ Task[1]: Run=?, TIMCount=10,  TRITime=10,  Hook=...     │  │
│  │ Task[2]: Run=?, TIMCount=10,  TRITime=10,  Hook=...     │  │
│  │ Task[3]: Run=?, TIMCount=300, TRITime=300, Hook=...     │  │
│  │ Task[4]: Run=?, TIMCount=500, TRITime=500, Hook=...     │  │
│  └─────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────┐    ┌──────────────────────┐         │
│  │ Task_Marks_Handler   │    │ Task_Pro_Handler     │         │
│  │ (中断中调用)          │    │ (主循环调用)          │         │
│  ├──────────────────────┤    ├──────────────────────┤         │
│  │ • 倒计时递减          │    │ • 检查Run标志        │         │
│  │ • 到期设置Run=1      │    │ • 执行任务函数       │         │
│  │ • 自动重载计数器      │    │ • 清除Run标志        │         │
│  └──────────────────────┘    └──────────────────────┘         │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────┐
│                    硬件抽象层 (HAL Layer)                       │
├────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐      │
│  │  GPIO    │  │  Timer0  │  │   ADC    │  │   PWM    │      │
│  │  配置    │  │  1ms中断 │  │  12位    │  │  蜂鸣器  │      │
│  └──────────┘  └──────────┘  └──────────┘  └──────────┘      │
│                                                                 │
│  ┌──────────┐  ┌──────────┐                                   │
│  │  UART    │  │  HC595   │                                   │
│  │  调试    │  │  LED驱动 │                                   │
│  └──────────┘  └──────────┘                                   │
│                                                                 │
└────────────────────────────────────────────────────────────────┘
                              │
                              ▼
┌────────────────────────────────────────────────────────────────┐
│                        硬件层 (Hardware)                        │
│                         AI8051U MCU                             │
│                     24MHz / 64KB Flash                          │
└────────────────────────────────────────────────────────────────┘
```

### 3.2 数据流图

```
┌─────────────┐         ┌─────────────┐         ┌─────────────┐
│ Timer0 ISR  │  标记   │ 主循环调度   │  调用   │  应用任务   │
│  (1ms中断)  │────────>│  检查Run标志 │────────>│  执行功能   │
└─────────────┘         └─────────────┘         └─────────────┘
       │                                               │
       │ 递减计数器                                    │ 更新显示缓冲
       │ 设置Run标志                                   │ 处理按键
       │                                               │ 读取传感器
       ▼                                               ▼
┌─────────────────────────────────────────────────────────────┐
│                    任务控制块 (TCB)                          │
│  Run | TIMCount | TRITime | TaskHook                        │
│  ────┼──────────┼─────────┼──────────                       │
│   1  |    0     |    1    | Sample_Display  ────┐           │
│   0  |    5     |   10    | Sample_MatrixKey    │           │
│   0  |    5     |   10    | Sample_adcKey       │           │
│   0  |  295     |  300    | Sample_NTC          │ 数据共享  │
│   0  |  495     |  500    | Sample_RTC  ────────┘           │
└─────────────────────────────────────────────────────────────┘
       │                                               │
       └───────────────┐               ┌───────────────┘
                       ▼               ▼
              ┌─────────────────────────────┐
              │    全局变量 / 数据缓冲       │
              ├─────────────────────────────┤
              │ LED8[8]      显示缓冲       │
              │ usrHour      时间变量       │
              │ KeyCode      按键码         │
              │ temperature  温度值         │
              └─────────────────────────────┘
```

---

## 四、性能分析与风险评估

### 4.1 当前性能指标

| 指标项 | 数值 | 评估 |
|--------|------|------|
| 中断响应时间 | < 5μs | ✅ 优秀 |
| 中断执行时间 | ~50μs (5个任务) | ✅ 良好 |
| 最小任务周期 | 1ms | ✅ 足够 |
| 任务调度延迟 | 不确定 (0~数ms) | ⚠️ 风险点 |
| CPU占用率 | 估计5-15% | ✅ 低负载 |
| 内存占用 | ~200B RAM | ✅ 极低 |

### 4.2 关键性能风险

#### ⚠️ 风险1：任务执行时间不可控

**问题描述：**
```c
// 任务按顺序执行，没有时间限制
void Task_Pro_Handler_Callback(void)
{
    for(i=0; i<Tasks_Max; i++)
    {
        if(Task_Comps[i].Run)
        {
            Task_Comps[i].TaskHook();  // 如果这个任务很慢？
        }
    }
}
```

**风险场景：**
- 如果 `Sample_Display()` 执行超过1ms，会导致：
  - 下一次中断来临时，任务还在执行
  - `Run`标志被覆盖，任务漏执行
  - 显示可能出现闪烁

**实测分析：**
```
Sample_Display() 执行时间:
  - HC595发送: 8bit × 2 × (约10μs) = 160μs
  - 逻辑处理: ~40μs
  - 总计: ~200μs ✅ 安全 (< 1ms)

Sample_MatrixKey() 执行时间:
  - IO延时: 60×2次 = 120μs
  - P0读写: ~20μs
  - 总计: ~150μs ✅ 安全

Sample_NTC() 执行时间:
  - ADC采样: ~100μs
  - 二分查找: ~50μs
  - 总计: ~150μs ✅ 安全
```

**结论：当前任务设计合理，无超时风险**

---

#### ⚠️ 风险2：任务累积执行时间

**问题：** 如果多个任务同时就绪（如10ms时），累积执行时间可能很长

**分析：**
```
T=10ms时，同时就绪的任务:
  Sample_Display:   200μs
  Sample_MatrixKey: 150μs
  Sample_adcKey:    200μs (ADC采样+处理)
  ────────────────────────
  总计:             550μs ✅ 仍然安全
```

**最坏情况（T=3000ms）：**
```
所有任务同时就绪:
  Task1-5总计: ~800μs ✅ 依然远小于1ms
```

---

#### ⚠️ 风险3：中断嵌套问题

**当前代码：**
```c
void Timer0_ISR_Handler (void) interrupt TMR0_VECTOR
{
    Task_Marks_Handler_Callback();  // 约50μs
}
```

**问题：** AI8051U默认允许中断嵌套，如果其他中断（如UART、ADC）触发，可能延长ISR执行时间

**建议：** 在ISR中禁用嵌套
```c
void Timer0_ISR_Handler (void) interrupt TMR0_VECTOR
{
    EA = 0;  // 禁止中断嵌套
    Task_Marks_Handler_Callback();
    EA = 1;  // 恢复中断
}
```

---

#### ⚠️ 风险4：主循环阻塞

**场景：** 如果某个任务进入死循环或长延时
```c
void Bad_Task(void)
{
    while(condition);  // 死循环 → 系统完全挂死
}
```

**建议：** 添加看门狗
```c
void main(void)
{
    WDT_CONTR = 0x35;  // 启用看门狗，约1s超时
    
    while(1)
    {
        WDT_CONTR |= 0x10;  // 喂狗
        Task_Pro_Handler_Callback();
    }
}
```

---

### 4.3 性能优化建议

#### 优化1：任务执行时间监控

```c
typedef struct 
{
    u8 Run;
    u16 TIMCount;
    u16 TRITime;
    u16 ExecTime;     // 新增：记录执行时间
    u16 MaxExecTime;  // 新增：记录最大执行时间
    void (*TaskHook)(void);
} TASK_COMPONENTS;

void Task_Pro_Handler_Callback(void)
{
    u8 i;
    u16 start, elapsed;
    
    for(i=0; i<Tasks_Max; i++)
    {
        if(Task_Comps[i].Run)
        {
            start = TH0 << 8 | TL0;  // 记录Timer0当前值
            
            Task_Comps[i].Run = 0;
            Task_Comps[i].TaskHook();
            
            elapsed = (TH0 << 8 | TL0) - start;  // 计算执行时间
            Task_Comps[i].ExecTime = elapsed;
            
            if(elapsed > Task_Comps[i].MaxExecTime)
                Task_Comps[i].MaxExecTime = elapsed;
            
            // 预警：如果执行时间超过周期的80%
            if(elapsed > Task_Comps[i].TRITime * 0.8)
            {
                printf("WARNING: Task%d overtime! %d/%d\n", 
                       i, elapsed, Task_Comps[i].TRITime);
            }
        }
    }
}
```

---

#### 优化2：任务优先级机制

**方法1：按优先级排序**
```c
// 高优先级任务放在前面
static TASK_COMPONENTS Task_Comps[]={
    {0, 1,   1,   Sample_Display},     // 优先级最高
    {0, 10,  10,  Sample_MatrixKey},
    {0, 10,  10,  Sample_adcKey},
    {0, 300, 300, Sample_NTC},
    {0, 500, 500, Sample_RTC},         // 优先级最低
};
```

**方法2：添加优先级字段**
```c
typedef struct 
{
    u8 Run;
    u8 Priority;  // 0=最高优先级
    u16 TIMCount;
    u16 TRITime;
    void (*TaskHook)(void);
} TASK_COMPONENTS;

void Task_Pro_Handler_Callback(void)
{
    u8 i, highest_priority = 0xFF;
    s8 task_to_run = -1;
    
    // 找到最高优先级的就绪任务
    for(i=0; i<Tasks_Max; i++)
    {
        if(Task_Comps[i].Run && Task_Comps[i].Priority < highest_priority)
        {
            highest_priority = Task_Comps[i].Priority;
            task_to_run = i;
        }
    }
    
    // 执行最高优先级任务
    if(task_to_run >= 0)
    {
        Task_Comps[task_to_run].Run = 0;
        Task_Comps[task_to_run].TaskHook();
    }
}
```

---

#### 优化3：任务抢占机制（适用于紧急任务）

```c
// 在中断中直接执行紧急任务
void Timer0_ISR_Handler (void) interrupt TMR0_VECTOR
{
    Task_Marks_Handler_Callback();
    
    // 紧急任务：如果显示任务就绪，立即执行
    if(Task_Comps[0].Run)  // Sample_Display
    {
        Task_Comps[0].Run = 0;
        Sample_Display();  // 中断中直接调用
    }
}
```

**注意：** 仅适用于执行时间极短（<100μs）的任务

---

#### 优化4：CPU占用率监控

```c
u16 idle_count = 0;  // 空闲计数器

void main(void)
{
    SYS_Init();
    
    while(1)
    {
        Task_Pro_Handler_Callback();
        idle_count++;  // 每次循环+1
    }
}

// 在1秒定时任务中计算CPU占用率
void Sample_CPU_Monitor(void)  // 每1s执行
{
    static u16 last_idle = 0;
    u16 idle_delta = idle_count - last_idle;
    
    // 假设空闲时idle_count可达1000000
    // CPU占用率 = (1 - idle_delta/1000000) * 100%
    u8 cpu_usage = 100 - (idle_delta / 10000);
    
    printf("CPU Usage: %d%%\n", cpu_usage);
    last_idle = idle_count;
}
```

---

## 五、6路呼吸灯/流水灯/RGB灯可行性分析

### 5.1 需求分析

| 功能 | 技术要求 | 挑战点 |
|------|----------|--------|
| 6路呼吸灯 | PWM输出，频率>200Hz，256级亮度 | 需要6个PWM通道 |
| 流水灯 | GPIO控制，刷新率10-50Hz | 简单，GPIO即可 |
| RGB灯 | 3×6=18路PWM / SPI驱动WS2812 | 硬件PWM不足 |

### 5.2 硬件资源评估

**AI8051U硬件PWM资源：**
- PWMA: 4通道 (PWM1-4)
- PWMB: 4通道 (PWM5-8)
- **总计: 8路硬件PWM** ✅ 足够6路呼吸灯

**GPIO资源：**
- P0-P7共64个IO
- 当前使用：~15个
- **剩余: ~49个** ✅ 足够

### 5.3 方案设计

#### 方案A：6路呼吸灯（硬件PWM）

```c
// 任务配置
static TASK_COMPONENTS Task_Comps[]={
    {0, 1,   1,   Sample_Display},      // 保留显示
    {0, 20,  20,  Sample_BreathLED},    // 新增：呼吸灯，20ms刷新
    {0, 500, 500, Sample_RTC},          // 保留时钟
};

// 呼吸灯任务
typedef struct {
    u8 brightness;   // 当前亮度 0-255
    s8 direction;    // 方向：1递增，-1递减
    u8 speed;        // 速度：每次增减的步长
} BREATH_LED;

BREATH_LED leds[6];

void Sample_BreathLED(void)  // 每20ms执行一次 (50Hz)
{
    u8 i;
    
    for(i=0; i<6; i++)
    {
        // 更新亮度
        leds[i].brightness += leds[i].direction * leds[i].speed;
        
        // 边界检查
        if(leds[i].brightness >= 255)
        {
            leds[i].brightness = 255;
            leds[i].direction = -1;  // 反向
        }
        else if(leds[i].brightness <= 0)
        {
            leds[i].brightness = 0;
            leds[i].direction = 1;
        }
        
        // 设置PWM占空比
        SetPWM_Duty(i+1, leds[i].brightness);  // PWM1-6
    }
}

// PWM配置函数
void SetPWM_Duty(u8 channel, u8 duty)  // duty: 0-255
{
    u16 ccr_value = (u16)duty * 8;  // ARR=2047时，8倍放大
    
    switch(channel)
    {
        case 1: PWMA_CCR1H = ccr_value >> 8; PWMA_CCR1L = ccr_value; break;
        case 2: PWMA_CCR2H = ccr_value >> 8; PWMA_CCR2L = ccr_value; break;
        case 3: PWMA_CCR3H = ccr_value >> 8; PWMA_CCR3L = ccr_value; break;
        case 4: PWMA_CCR4H = ccr_value >> 8; PWMA_CCR4L = ccr_value; break;
        case 5: PWMB_CCR1H = ccr_value >> 8; PWMB_CCR1L = ccr_value; break;
        case 6: PWMB_CCR2H = ccr_value >> 8; PWMB_CCR2L = ccr_value; break;
    }
}

// PWM初始化
void PWM_BreathLED_Init(void)
{
    // PWMA配置 (PWM1-4)
    PWMA_CCER1 = 0x00;
    PWMA_CCMR1 = 0x60;  // CH1 PWM模式1
    PWMA_CCMR2 = 0x60;  // CH2 PWM模式1
    PWMA_CCMR3 = 0x60;  // CH3 PWM模式1
    PWMA_CCMR4 = 0x60;  // CH4 PWM模式1
    PWMA_CCER1 = 0x11;  // CH1,CH2使能
    PWMA_CCER2 = 0x11;  // CH3,CH4使能
    
    PWMA_ARRH = 0x07;   // ARR=2047，频率=24MHz/2048≈11.7kHz
    PWMA_ARRL = 0xFF;
    
    PWMA_ENO = 0x0F;    // PWM1-4输出使能
    PWMA_BKR = 0x80;
    PWMA_CR1 = 0x01;    // 启动计数器
    
    // PWMB配置 (PWM5-6)
    PWMB_CCER1 = 0x00;
    PWMB_CCMR1 = 0x60;
    PWMB_CCMR2 = 0x60;
    PWMB_CCER1 = 0x11;
    
    PWMB_ARRH = 0x07;
    PWMB_ARRL = 0xFF;
    
    PWMB_ENO = 0x03;    // PWM5-6输出使能
    PWMB_BKR = 0x80;
    PWMB_CR1 = 0x01;
    
    // 初始化LED参数
    for(u8 i=0; i<6; i++)
    {
        leds[i].brightness = i * 40;  // 错开初始亮度
        leds[i].direction = 1;
        leds[i].speed = 2;  // 亮度变化速度
    }
}
```

**性能分析：**
- 任务执行时间: 6×30μs = 180μs ✅
- 刷新率: 50Hz (20ms) ✅ 足够流畅
- CPU占用: <1% ✅

---

#### 方案B：6路RGB灯（18路PWM - 不推荐）

**问题：** AI8051U只有8路硬件PWM，不足18路

**替代方案：**

**方案B1：软件PWM（不推荐）**
```c
// 需要占用大量CPU，不适合本架构
```

**方案B2：WS2812驱动（推荐）** ✅
```c
// 使用SPI+DMA驱动WS2812
// 优势：仅占用1个SPI引脚，可控制数百个RGB灯
// 参考项目中的 80-SPI-DMA发送-驱动WS2812彩灯

static TASK_COMPONENTS Task_Comps[]={
    {0, 1,   1,   Sample_Display},
    {0, 50,  50,  Sample_WS2812},  // 50ms刷新 (20fps)
    {0, 500, 500, Sample_RTC},
};

void Sample_WS2812(void)
{
    static u8 hue = 0;
    u8 i;
    
    for(i=0; i<6; i++)
    {
        // 生成彩虹色
        RGB_Buffer[i] = HSV_to_RGB((hue + i*40) % 360, 255, 255);
    }
    
    WS2812_Send_DMA(RGB_Buffer, 6);  // DMA发送，不阻塞CPU
    hue += 2;  // 色相旋转
}
```

---

#### 方案C：流水灯（最简单）

```c
static TASK_COMPONENTS Task_Comps[]={
    {0, 1,   1,   Sample_Display},
    {0, 100, 100, Sample_FlowLED},  // 100ms刷新
    {0, 500, 500, Sample_RTC},
};

void Sample_FlowLED(void)
{
    static u8 pos = 0;
    u8 i;
    
    // 清除所有LED
    for(i=0; i<6; i++)
        LED_OFF(i);
    
    // 点亮当前位置
    LED_ON(pos);
    
    // 移动到下一位置
    if(++pos >= 6) pos = 0;
}

#define LED_ON(n)   P2 &= ~(1 << (n))  // 假设P2.0-P2.5控制LED
#define LED_OFF(n)  P2 |=  (1 << (n))
```

**性能：** 执行时间<20μs，几乎无CPU占用 ✅

---

### 5.4 完整项目架构（6路呼吸灯+流水灯）

```c
static TASK_COMPONENTS Task_Comps[]={
    {0, 1,   1,   Sample_Display},      // 数码管显示
    {0, 20,  20,  Sample_BreathLED},    // 6路呼吸灯
    {0, 100, 100, Sample_FlowLED},      // 流水灯
    {0, 10,  10,  Sample_MatrixKey},    // 按键切换模式
    {0, 500, 500, Sample_RTC},          // 时钟
};
```

**功能：**
- 按键切换呼吸灯模式（速度、颜色等）
- 数码管显示当前模式
- 流水灯背景效果

**资源占用：**
- Flash: <10KB
- RAM: <500B
- CPU: <10%

---

## 六、总结与建议

### ✅ 可行性结论

| 项目 | 可行性 | 推荐方案 |
|------|--------|----------|
| 6路呼吸灯 | ✅ 完全可行 | 硬件PWM (PWMA+PWMB) |
| 流水灯 | ✅ 完全可行 | GPIO直接控制 |
| 6路RGB灯 | ⚠️ 有限可行 | WS2812 (SPI+DMA) |

### 🎯 最佳实践方案

**推荐配置：**
```c
// 任务列表
1. Sample_Display      (1ms)   - 数码管显示
2. Sample_BreathLED    (20ms)  - 6路呼吸灯
3. Sample_FlowLED      (100ms) - 流水灯效果
4. Sample_Key          (10ms)  - 按键控制
5. Sample_RTC          (500ms) - 时钟显示
```

**预期性能：**
- CPU占用: <15%
- 内存占用: <600B
- 显示刷新: 125Hz (无闪烁)
- 呼吸灯刷新: 50Hz (流畅)
- 响应延迟: <100ms

### ⚠️ 注意事项

1. **避免在任务中使用延时函数** (`delay_ms()`)
2. **确保每个任务执行时间 < 其周期的50%**
3. **添加看门狗保护**
4. **使用DMA减少CPU占用**（如WS2812驱动）

---

**结论：** 基于当前任务调度框架实现6路呼吸灯/流水灯/RGB灯**完全可行**，且有充足的性能余量！建议从呼吸灯开始实现，逐步扩展功能。

